---
phase: 17-end-to-end-message-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/types/daemon.ts
  - packages/shared/src/channels/types.ts
  - packages/shared/src/channels/adapters/slack-adapter.ts
  - packages/shared/src/channels/adapters/whatsapp-adapter.ts
  - packages/shared/src/daemon/entry.ts
  - packages/shared/src/daemon/channel-runner.ts
autonomous: true
must_haves:
  truths:
    - DaemonEvent union includes process_message variant with messageId, channelId, workspaceId, sessionKey, content, metadata
    - DaemonCommand union includes message_processed variant with messageId, response, success, error?
    - ChannelAdapter interface has optional send(message OutboundMessage) method
    - OutboundMessage type has channelId, content, threadId?, metadata?
    - SlackChannelAdapter.send() calls WebClient.chat.postMessage()
    - WhatsAppChannelAdapter.send() calls sock.sendMessage()
    - Daemon entry runs a consumer timer (setInterval) that dequeues inbound messages and emits process_message events
    - Daemon entry handles message_processed command by marking processed + enqueuing outbound + delivering via adapter
    - Daemon entry resets processing messages to pending on startup (recovery query)
    - Consumer timer respects a concurrency limit (default 3) before emitting process_message
    - ChannelRunner has a deliverOutbound(channelId, message) method that routes to the correct adapter
  artifacts:
    - packages/core/src/types/daemon.ts with process_message and message_processed variants
    - packages/shared/src/channels/types.ts with OutboundMessage type and send() on ChannelAdapter
    - packages/shared/src/channels/adapters/slack-adapter.ts with send() implementation
    - packages/shared/src/channels/adapters/whatsapp-adapter.ts with send() implementation
    - packages/shared/src/daemon/entry.ts with consumer timer, message_processed handler, recovery query
    - packages/shared/src/daemon/channel-runner.ts with deliverOutbound() method
  key_links:
    - .planning/phases/pending/17-end-to-end-message-processing/17-RESEARCH.md
    - packages/core/src/types/daemon.ts
    - packages/shared/src/daemon/entry.ts
    - packages/shared/src/daemon/channel-runner.ts
---

<objective>
Add daemon-side message processing: IPC types for process_message/message_processed, outbound send() on adapters, consumer loop in daemon entry, and outbound delivery in ChannelRunner.

Purpose: The daemon can dequeue inbound messages, request processing from the main process, receive responses, and deliver outbound messages back to the originating channel adapter.

Output: Modified type definitions, adapter send methods, daemon consumer loop with concurrency control, and ChannelRunner outbound delivery.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/phases/pending/17-end-to-end-message-processing/17-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md

@packages/core/src/types/daemon.ts
@packages/shared/src/daemon/types.ts
@packages/shared/src/channels/types.ts
@packages/shared/src/channels/adapters/slack-adapter.ts
@packages/shared/src/channels/adapters/whatsapp-adapter.ts
@packages/shared/src/daemon/entry.ts
@packages/shared/src/daemon/channel-runner.ts
@packages/shared/src/daemon/message-queue.ts
@packages/shared/src/daemon/ipc.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IPC types and OutboundMessage, implement adapter send()</name>
  <files>
    packages/core/src/types/daemon.ts
    packages/shared/src/channels/types.ts
    packages/shared/src/channels/adapters/slack-adapter.ts
    packages/shared/src/channels/adapters/whatsapp-adapter.ts
  </files>
  <action>
1. In `packages/core/src/types/daemon.ts`, add a `process_message` variant to the `DaemonEvent` union:
   ```typescript
   | {
       type: 'process_message';
       messageId: number;
       channelId: string;
       workspaceId: string;
       sessionKey: string;
       content: string;
       metadata: Record<string, unknown>;
     }
   ```
   Add a `message_processed` variant to the `DaemonCommand` union:
   ```typescript
   | {
       type: 'message_processed';
       messageId: number;
       response: string;
       success: boolean;
       error?: string;
     }
   ```

2. In `packages/shared/src/channels/types.ts`, add an `OutboundMessage` interface:
   ```typescript
   export interface OutboundMessage {
     channelId: string;
     content: string;
     threadId?: string;
     metadata?: Record<string, unknown>;
   }
   ```
   Add an optional `send` method to the `ChannelAdapter` interface:
   ```typescript
   send?(message: OutboundMessage): Promise<void>;
   ```
   Place it after `getLastError()`.

3. In `packages/shared/src/channels/adapters/slack-adapter.ts`:
   - Import `OutboundMessage` from `../types.ts`
   - Add a `send(message: OutboundMessage): Promise<void>` method to `SlackChannelAdapter`:
     ```typescript
     async send(message: OutboundMessage): Promise<void> {
       if (!this.client) throw new Error('SlackChannelAdapter not configured');
       await this.client.chat.postMessage({
         channel: message.channelId,
         text: message.content,
         thread_ts: message.threadId,
       });
     }
     ```

4. In `packages/shared/src/channels/adapters/whatsapp-adapter.ts`:
   - Import `OutboundMessage` from `../types.ts`
   - Add a `send(message: OutboundMessage): Promise<void>` method to `WhatsAppChannelAdapter`:
     ```typescript
     async send(message: OutboundMessage): Promise<void> {
       if (!this.sock) throw new Error('WhatsAppChannelAdapter not connected');
       await this.sock.sendMessage(message.channelId, { text: message.content });
     }
     ```

Do NOT change any existing method signatures. The `send` method on adapters is additive only.
  </action>
  <verify>
Run `bun run typecheck:all` from monorepo root. All type checks pass. Verify the new DaemonEvent/DaemonCommand variants are recognized by the discriminated union (no `never` type errors).
  </verify>
  <done>
- DaemonEvent has process_message variant, DaemonCommand has message_processed variant
- OutboundMessage type exported from channels/types.ts
- ChannelAdapter interface includes optional send() method
- SlackChannelAdapter.send() calls WebClient.chat.postMessage()
- WhatsAppChannelAdapter.send() calls sock.sendMessage()
- typecheck passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add message consumer loop and recovery to daemon entry</name>
  <files>
    packages/shared/src/daemon/entry.ts
  </files>
  <action>
In `packages/shared/src/daemon/entry.ts`:

1. **Recovery query on startup.** After `MessageQueue` is initialized and before `emit({ type: 'status_changed', status: 'running' })`, add a recovery step that resets any `processing` messages back to `pending`:
   ```typescript
   queue.getDb().run("UPDATE messages SET status = 'pending' WHERE status = 'processing'");
   log('Reset stale processing messages to pending');
   ```

2. **Concurrency semaphore.** Add a simple concurrency control above the `main()` function or at the top of `main()` after queue init. Use inline tracking (no separate class needed):
   ```typescript
   const MAX_CONCURRENT = 3;
   let activeProcessing = 0;
   const pendingMessages: Array<{ msg: QueuedMessage; workspaceId: string }> = [];
   ```
   The `workspaceId` is extracted from `msg.payload.metadata.workspaceId`.

3. **Consumer timer.** After `state.channelRunner` is potentially set (after `emit({ type: 'status_changed', status: 'running' })`), add a consumer interval:
   ```typescript
   const CONSUMER_INTERVAL_MS = 1000;
   const consumerTimer = setInterval(() => {
     // Process waiting messages first
     while (activeProcessing < MAX_CONCURRENT && pendingMessages.length > 0) {
       const { msg } = pendingMessages.shift()!;
       emitProcessMessage(msg);
     }
     // Dequeue new messages
     while (activeProcessing < MAX_CONCURRENT) {
       const msg = queue.dequeue('inbound');
       if (!msg) break;
       emitProcessMessage(msg);
     }
   }, CONSUMER_INTERVAL_MS);
   ```
   Where `emitProcessMessage` is a helper:
   ```typescript
   function emitProcessMessage(msg: QueuedMessage): void {
     activeProcessing++;
     const payload = msg.payload as { content: string; metadata: Record<string, unknown> };
     emit({
       type: 'process_message',
       messageId: msg.id,
       channelId: msg.channelId,
       workspaceId: (payload.metadata?.workspaceId as string) ?? '',
       sessionKey: (payload.metadata?.sessionKey as string) ?? '',
       content: payload.content ?? '',
       metadata: payload.metadata ?? {},
     });
   }
   ```

4. **Handle `message_processed` command.** Add a new case in `handleCommand`:
   ```typescript
   case 'message_processed': {
     activeProcessing = Math.max(0, activeProcessing - 1);
     if (cmd.success) {
       queue.markProcessed(cmd.messageId);
       log(`Message ${cmd.messageId} processed successfully`);
       // Enqueue outbound response and deliver
       if (cmd.response && state.channelRunner) {
         const originalMsg = queue.getDb().query(
           'SELECT channel_id, payload FROM messages WHERE id = $id'
         ).get({ $id: cmd.messageId }) as { channel_id: string; payload: string } | null;
         if (originalMsg) {
           const originalPayload = JSON.parse(originalMsg.payload) as {
             metadata?: Record<string, unknown>;
             replyTo?: { threadId?: string };
           };
           const outboundId = queue.enqueue('outbound', originalMsg.channel_id, {
             content: cmd.response,
             channelId: originalPayload.metadata?.slackChannel ?? originalPayload.metadata?.jid ?? '',
             threadId: originalPayload.replyTo?.threadId,
           });
           state.channelRunner.deliverOutbound(originalMsg.channel_id, {
             channelId: (originalPayload.metadata?.slackChannel ?? originalPayload.metadata?.jid ?? '') as string,
             content: cmd.response,
             threadId: originalPayload.replyTo?.threadId as string | undefined,
           }).then(() => {
             queue.markProcessed(outboundId);
             emit({ type: 'message_sent', channelId: originalMsg.channel_id, messageId: String(outboundId) });
           }).catch((err) => {
             queue.markFailed(outboundId, err instanceof Error ? err.message : String(err));
             log(`Outbound delivery failed for message ${outboundId}: ${err}`);
           });
         }
       }
     } else {
       queue.markFailed(cmd.messageId, cmd.error ?? 'unknown error');
       log(`Message ${cmd.messageId} processing failed: ${cmd.error}`);
     }
     break;
   }
   ```

5. **Clear consumer timer on shutdown.** Before the scheduler stop in the graceful shutdown section:
   ```typescript
   clearInterval(consumerTimer);
   log('Consumer timer stopped');
   ```

Import `type { QueuedMessage }` from `./types.ts` at the top. Import `type { OutboundMessage }` from `../channels/types.ts` only if needed by the deliverOutbound call shape.

Do NOT modify the existing stdin reader loop or the command parsing logic. The consumer timer is additive alongside the existing event loop.
  </action>
  <verify>
Run `bun run typecheck:all`. Check that entry.ts compiles with the new DaemonCommand case for `message_processed` and the new consumer timer. The switch statement must be exhaustive (no unhandled cases).
  </verify>
  <done>
- Recovery query resets processing -> pending on startup
- Consumer timer polls queue every 1s and emits process_message events
- Concurrency limited to MAX_CONCURRENT (3)
- message_processed command marks queue, enqueues outbound, delivers via ChannelRunner
- Consumer timer cleared during graceful shutdown
- typecheck passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Add deliverOutbound() to ChannelRunner</name>
  <files>
    packages/shared/src/daemon/channel-runner.ts
  </files>
  <action>
In `packages/shared/src/daemon/channel-runner.ts`:

1. Import `OutboundMessage` from `../channels/types.ts`.

2. Add a `deliverOutbound` method to the `ChannelRunner` class:
   ```typescript
   async deliverOutbound(channelSlug: string, message: OutboundMessage): Promise<void> {
     const running = this.adapters.get(channelSlug);
     if (!running) {
       throw new Error(`No running adapter for channel: ${channelSlug}`);
     }
     if (!running.adapter.send) {
       throw new Error(`Adapter ${channelSlug} does not support send()`);
     }
     await running.adapter.send(message);
     this.log(`Delivered outbound message to ${channelSlug}`);
   }
   ```

This method looks up the running adapter by slug and calls its `send()` method. It throws if the adapter is not running or does not implement `send()`.

Do NOT change any existing methods in ChannelRunner.
  </action>
  <verify>
Run `bun run typecheck:all`. Verify ChannelRunner compiles with the new method. Check that `OutboundMessage` import resolves correctly.
  </verify>
  <done>
- ChannelRunner.deliverOutbound() routes outbound messages to the correct adapter by slug
- Throws clear errors for missing adapter or unsupported send()
- typecheck passes
  </done>
</task>

</tasks>

<verification>
```bash
bun run typecheck:all
bun test packages/shared
```

All type checks and existing tests pass. No regressions in daemon, channel, or adapter functionality.
</verification>

<success_criteria>
- DaemonEvent/DaemonCommand types extended with process_message and message_processed
- ChannelAdapter interface includes optional send(), OutboundMessage type exported
- Slack and WhatsApp adapters implement send()
- Daemon entry has consumer loop with concurrency control and recovery query
- Daemon entry handles message_processed command with outbound delivery
- ChannelRunner.deliverOutbound() routes to correct adapter
- All type checks pass, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/pending/17-end-to-end-message-processing/17-01-SUMMARY.md`
</output>

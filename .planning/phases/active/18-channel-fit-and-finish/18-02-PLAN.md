---
phase: 18-channel-fit-and-finish
plan: 02
type: execute
wave: 2
depends_on: [18-01]
files_modified:
  - packages/shared/src/channels/adapters/slack-adapter.ts
  - packages/shared/src/channels/__tests__/slack-adapter.test.ts
  - packages/shared/src/channels/types.ts
  - packages/shared/src/channels/index.ts
  - packages/shared/src/daemon/channel-runner.ts
  - packages/shared/src/daemon/__tests__/channel-runner.test.ts
  - apps/electron/src/main/channel-config-delivery.ts
  - apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx
  - package.json
autonomous: true
must_haves:
  truths:
    - Slack slash commands (e.g., /kata) are received by the daemon and processed as inbound messages
    - SlackChannelAdapter operates in hybrid mode (poll for history + subscribe for slash commands)
    - App-level token (xapp-) is stored alongside bot token (xoxb-) per channel
    - Slash command payloads produce ChannelMessages with command name in metadata
    - Slash command acknowledgment responds within 3 seconds (Slack requirement)
    - Channel creation UI has an optional "App-Level Token" field for Slack channels
    - Existing polling behavior is unchanged when no app-level token is configured
  artifacts:
    - packages/shared/src/channels/adapters/slack-adapter.ts with SocketModeClient integration
    - packages/shared/src/channels/types.ts with appToken in ChannelConfig credentials
    - apps/electron/src/main/channel-config-delivery.ts with app-level token resolution
    - apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx with app token field
  key_links:
    - SocketModeClient.on('slash_commands') -> toChannelMessage() -> onMessage callback
    - ChannelConfig.credentials.appTokenSlug -> deliverChannelConfigs -> tokens map -> adapter.configure()
    - SlackChannelAdapter.start() initializes both poll timer AND SocketModeClient (when appToken provided)
---

<objective>
Add Socket Mode support to SlackChannelAdapter for receiving slash commands. The adapter becomes hybrid: polling for message history (existing behavior) and subscribing via WebSocket for slash command events. Requires a new @slack/socket-mode dependency, an app-level token credential field, and UI support for entering the token.

Purpose: Users can interact with the Kata agent via Slack slash commands (e.g., `/kata ask about the deployment`), receiving immediate acknowledgment and asynchronous responses.

Output: Modified slack-adapter.ts with hybrid poll+subscribe, updated credential model, channel config delivery, and UI form field.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/phases/pending/18-channel-fit-and-finish/18-RESEARCH.md
@.planning/STATE.md

@packages/shared/src/channels/adapters/slack-adapter.ts
@packages/shared/src/channels/__tests__/slack-adapter.test.ts
@packages/shared/src/channels/types.ts
@packages/shared/src/channels/index.ts
@packages/shared/src/daemon/channel-runner.ts
@packages/shared/src/daemon/__tests__/channel-runner.test.ts
@apps/electron/src/main/channel-config-delivery.ts
@apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx
@packages/shared/src/credentials/types.ts
@packages/shared/src/credentials/manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @slack/socket-mode and implement hybrid poll+subscribe in SlackChannelAdapter</name>
  <files>
    package.json
    packages/shared/src/channels/adapters/slack-adapter.ts
    packages/shared/src/channels/__tests__/slack-adapter.test.ts
    packages/shared/src/channels/types.ts
  </files>
  <action>
1. Install `@slack/socket-mode` from the monorepo root:
   ```bash
   bun add @slack/socket-mode
   ```

2. In `packages/shared/src/channels/types.ts`, add an optional `appTokenSlug` field to the `credentials` object within `ChannelConfig`:
   ```typescript
   credentials: {
     sourceSlug?: string;
     channelSlug?: string;
     /** Slug for app-level token credential (xapp-), required for Socket Mode (slash commands) */
     appTokenSlug?: string;
   };
   ```
   This is additive. Existing configs without `appTokenSlug` continue to work (poll-only mode).

3. In `packages/shared/src/channels/adapters/slack-adapter.ts`:

   a. Import `SocketModeClient` from `@slack/socket-mode`.

   b. Update the `configure()` method signature to accept an optional `appToken`:
      ```typescript
      configure(token: string, pollingState?: PollingStateFns, appToken?: string): void {
        this.client = new WebClient(token, { retryConfig: { retries: 3 } });
        this.pollingStateFns = pollingState ?? null;
        this.appToken = appToken ?? null;
      }
      ```
      Add a private `appToken` field: `private appToken: string | null = null;`
      Add a private `socketClient` field: `private socketClient: SocketModeClient | null = null;`

   c. In the `start()` method, after existing polling setup, add Socket Mode initialization when `appToken` is available:
      ```typescript
      // Start Socket Mode for slash commands (if app-level token provided)
      if (this.appToken) {
        this.socketClient = new SocketModeClient({ appToken: this.appToken });

        this.socketClient.on('slash_commands', async ({ body, ack }) => {
          // Acknowledge within 3 seconds (Slack requirement)
          await ack({ text: 'Processing...' });

          // Convert slash command to ChannelMessage
          const channelMessage: ChannelMessage = {
            id: `cmd-${body.trigger_id}`,
            channelId: this._id,
            source: body.user_id,
            timestamp: Date.now(),
            content: body.text ? `${body.command} ${body.text}` : body.command,
            metadata: {
              slackChannel: body.channel_id,
              team: body.team_id,
              command: body.command,
              triggerId: body.trigger_id,
              responseUrl: body.response_url,
            },
            // No thread context for slash commands (they are top-level)
          };
          onMessage(channelMessage);
        });

        await this.socketClient.start();
      }
      ```

      Store the `onMessage` callback reference so it's accessible to the socket handler. Add `private onMessageCallback: ((msg: ChannelMessage) => void) | null = null;` and set it in `start()` before the socket setup:
      ```typescript
      this.onMessageCallback = onMessage;
      ```

      Actually, the cleaner approach is to use a closure over `onMessage` since it's already in scope within `start()`. The code above already does this (the socket event handler references `onMessage` from the `start()` method's parameter).

   d. In `stop()`, disconnect the socket client:
      ```typescript
      async stop(): Promise<void> {
        if (this.pollTimer) {
          clearInterval(this.pollTimer);
          this.pollTimer = null;
        }
        if (this.socketClient) {
          await this.socketClient.disconnect();
          this.socketClient = null;
        }
        this.client = null;
        this.appToken = null;
        this.healthy = false;
      }
      ```

   e. Update `isHealthy()` to consider socket client state. If socket mode is configured but disconnected, report unhealthy:
      ```typescript
      isHealthy(): boolean {
        if (this.appToken && this.socketClient && !this.socketClient.isActive()) {
          return false;
        }
        return this.healthy;
      }
      ```
      Note: Check if `SocketModeClient` has an `isActive()` method. If not, track connection state via events. The `SocketModeClient` extends EventEmitter and emits 'connected' and 'disconnected' events. Add a `private socketConnected = false` field, listen for these events in start(), and use that field in isHealthy().

4. In `packages/shared/src/channels/__tests__/slack-adapter.test.ts`, add tests:
   - Test that `start()` does NOT create a SocketModeClient when no appToken is provided (backward compat).
   - Test that `start()` creates and starts a SocketModeClient when appToken is provided.
   - Test that `stop()` disconnects the socket client.
   - Mock `@slack/socket-mode` SocketModeClient (the daemon runs as Bun subprocess, so mocking is fine for unit tests).

Do NOT change the polling logic or `toChannelMessage()` for regular messages. The Socket Mode handling is purely additive.
  </action>
  <verify>
```bash
bun run typecheck:all
bun test packages/shared/src/channels/__tests__/slack-adapter.test.ts
```
Type checks pass. Slash command handling tests pass. Existing polling tests still pass.
  </verify>
  <done>
- @slack/socket-mode installed
- ChannelConfig.credentials includes optional appTokenSlug
- SlackChannelAdapter.configure() accepts optional appToken
- SlackChannelAdapter.start() initializes SocketModeClient when appToken provided
- Slash commands are acknowledged and converted to ChannelMessages
- stop() disconnects socket client
- Existing polling behavior unchanged when no appToken
- Tests verify hybrid mode and backward compatibility
- typecheck passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire app-level token through config delivery, ChannelRunner, and UI</name>
  <files>
    packages/shared/src/daemon/channel-runner.ts
    packages/shared/src/daemon/__tests__/channel-runner.test.ts
    apps/electron/src/main/channel-config-delivery.ts
    apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx
  </files>
  <action>
**Part A: Config delivery resolves app-level token**

1. In `apps/electron/src/main/channel-config-delivery.ts`, in the Slack credential resolution block (around line 97), add app-level token resolution:

   After the existing `tokens[config.credentials.channelSlug] = token` line, check for `appTokenSlug`:
   ```typescript
   // Resolve app-level token for Socket Mode (slash commands)
   if (config.credentials.appTokenSlug) {
     const appToken = await credManager.getChannelCredential(workspace.id, config.credentials.appTokenSlug)
     if (appToken) {
       tokens[config.credentials.appTokenSlug] = appToken
     } else {
       console.warn(`[channel-config-delivery] Missing app-level token for channel "${slug}" (appTokenSlug: ${config.credentials.appTokenSlug})`)
     }
   }
   ```

   This reuses the existing `getChannelCredential` method with the `appTokenSlug` as the credential key. The app-level token is stored as a separate channel credential with its own slug (e.g., `my-slack-app-token`).

**Part B: ChannelRunner passes appToken to adapter.configure()**

2. In `packages/shared/src/daemon/channel-runner.ts`, in the `startAll()` method's Slack case (around line 74), resolve the app-level token and pass it to `configure()`:

   After the existing `token` resolution:
   ```typescript
   case 'slack': {
     if (!credKey) {
       this.emit({ type: 'plugin_error', pluginId: config.slug, error: 'No credential key configured' });
       continue;
     }
     const token = wsConfig.tokens.get(credKey);
     if (!token) {
       this.emit({
         type: 'plugin_error',
         pluginId: config.slug,
         error: `No token found for credential key: ${credKey}`,
       });
       continue;
     }
     // Resolve optional app-level token for Socket Mode
     const appToken = config.credentials.appTokenSlug
       ? wsConfig.tokens.get(config.credentials.appTokenSlug) ?? null
       : null;

     (adapter as SlackChannelAdapter).configure(
       token,
       {
         get: (aid, cid) => this.queue.getPollingState(aid, cid),
         set: (aid, cid, ts) => this.queue.setPollingState(aid, cid, ts),
       },
       appToken ?? undefined,
     );
     break;
   }
   ```

3. In `packages/shared/src/daemon/__tests__/channel-runner.test.ts`, add a test:
   - Verify that when a Slack config has `credentials.appTokenSlug` and the corresponding token exists in the tokens map, the adapter's `configure()` is called with three arguments (token, pollingState, appToken).

**Part C: Channel creation UI adds app-level token field**

4. In `apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx`:

   a. Add `appToken` to the `ChannelFormState` interface:
      ```typescript
      interface ChannelFormState {
        adapter: "slack" | "whatsapp" | "";
        name: string;
        credential: string;
        appToken: string;   // <-- new
        channelIds: string;
        triggerPatterns: string;
        pollIntervalMs: number;
      }
      ```

   b. Add `appToken: ""` to `initialFormState`.

   c. In the form JSX for Slack adapter, add an "App-Level Token (optional)" field after the existing Bot Token field. Use `SettingsSecretInput`:
      ```tsx
      {form.adapter === "slack" && (
        <>
          {/* Existing bot token field */}
          <SettingsSecretInput ... />

          {/* App-level token for slash commands */}
          <SettingsSecretInput
            label="App-Level Token (optional)"
            description="Required for slash commands. Starts with xapp-. Get it from your Slack app's Basic Information page."
            value={form.appToken}
            onChange={(v) => setForm((f) => ({ ...f, appToken: v }))}
            placeholder="xapp-..."
          />
        </>
      )}
      ```

   d. In the form submission handler, when creating the channel config:
      - Generate an `appTokenSlug` from the channel name (e.g., `${slug}-app-token`).
      - If `form.appToken` is non-empty, store it as a channel credential using the IPC call pattern.
      - Include `appTokenSlug` in the `credentials` field of the config.

      In the config object creation:
      ```typescript
      const config: ChannelConfig = {
        slug,
        enabled: true,
        adapter: form.adapter,
        pollIntervalMs: form.pollIntervalMs,
        credentials: {
          channelSlug: slug,
          ...(form.appToken ? { appTokenSlug: `${slug}-app-token` } : {}),
        },
        filter: { ... },
      };
      ```

      After writing the config, store the app-level token credential:
      ```typescript
      if (form.appToken) {
        await window.api.invoke("SET_CHANNEL_CREDENTIAL", activeWorkspace.id, `${slug}-app-token`, form.appToken);
      }
      ```

      Verify that `SET_CHANNEL_CREDENTIAL` IPC channel already exists and handles this pattern. It should, since channel credentials are stored by arbitrary slug.

Do NOT add new IPC channels. Reuse the existing `SET_CHANNEL_CREDENTIAL` handler. Do NOT modify credential types (channel_credential key already supports arbitrary slugs).
  </action>
  <verify>
```bash
bun run typecheck:all
bun test packages/shared/src/daemon/__tests__/channel-runner.test.ts
```
Type checks pass. ChannelRunner test verifies appToken passthrough. UI renders the app token field.
  </verify>
  <done>
- deliverChannelConfigs resolves app-level tokens via appTokenSlug
- ChannelRunner passes appToken to SlackChannelAdapter.configure()
- Channel creation form has optional "App-Level Token" field for Slack
- App-level token stored as channel credential with slug `{channel}-app-token`
- ChannelConfig credentials type includes optional appTokenSlug
- Existing channels without appToken continue to work (poll-only)
- typecheck passes, tests pass
  </done>
</task>

</tasks>

<verification>
```bash
bun run typecheck:all
bun test packages/shared
```

All type checks pass. Slack adapter supports hybrid poll+subscribe mode. Slash commands are received, acknowledged within 3 seconds, and converted to ChannelMessages. App-level token flows from UI through config delivery to the adapter. Existing polling behavior is preserved when no app token is configured.
</verification>

<success_criteria>
- @slack/socket-mode installed and SocketModeClient integrated into SlackChannelAdapter
- Slash commands received via WebSocket, acknowledged, converted to ChannelMessage
- App-level token stored, delivered, and consumed alongside bot token
- Channel creation UI supports optional app-level token input
- Hybrid mode: polling continues for message history, Socket Mode handles slash commands
- No app-level token = poll-only (backward compatible)
- All type checks pass, all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/pending/18-channel-fit-and-finish/18-02-SUMMARY.md`
</output>

---
phase: 05-real-time-updates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/electron/package.json
  - apps/electron/src/main/lib/git-watcher.ts
  - apps/electron/src/main/ipc.ts
  - apps/electron/src/shared/types.ts
  - apps/electron/src/preload/index.ts
autonomous: true

must_haves:
  truths:
    - "Git status refreshes automatically when .git directory changes"
    - "File watching does not cause CPU spikes or excessive process spawning"
    - "Watcher cleanup happens on workspace switch"
  artifacts:
    - path: "apps/electron/src/main/lib/git-watcher.ts"
      provides: "GitWatcher class with chokidar"
      exports: ["GitWatcher"]
    - path: "apps/electron/src/shared/types.ts"
      provides: "GIT_STATUS_CHANGED IPC channel"
      contains: "GIT_STATUS_CHANGED"
    - path: "apps/electron/src/preload/index.ts"
      provides: "onGitStatusChanged listener"
      contains: "onGitStatusChanged"
  key_links:
    - from: "apps/electron/src/main/lib/git-watcher.ts"
      to: "apps/electron/src/main/ipc.ts"
      via: "GitWatcher integration in IPC layer"
      pattern: "GitWatcher"
    - from: "apps/electron/src/main/ipc.ts"
      to: "apps/electron/src/preload/index.ts"
      via: "GIT_STATUS_CHANGED broadcast"
      pattern: "GIT_STATUS_CHANGED"
---

<objective>
Create GitWatcher class using chokidar to watch .git directory changes and broadcast to renderer

Purpose: Enable automatic git status refresh when user performs git operations (checkout, commit, etc.)
Output: GitWatcher module with IPC broadcast infrastructure
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-updates/05-RESEARCH.md

# Existing patterns
@apps/electron/src/main/lib/config-watcher.ts
@apps/electron/src/main/ipc.ts
@apps/electron/src/shared/types.ts
@apps/electron/src/preload/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install chokidar and create GitWatcher class</name>
  <files>
    apps/electron/package.json
    apps/electron/src/main/lib/git-watcher.ts
  </files>
  <action>
1. Install chokidar v4.x in apps/electron:
   ```bash
   cd apps/electron && bun add chokidar@^4
   ```

2. Create `apps/electron/src/main/lib/git-watcher.ts` following the pattern from ConfigWatcher:

```typescript
/**
 * Git File Watcher
 *
 * Watches selective .git paths for changes to detect branch switches,
 * commits, and other git operations. Uses chokidar for cross-platform
 * reliability (handles macOS, Linux, Windows differences).
 *
 * Watched paths:
 * - .git/HEAD - Branch reference (changes on checkout, branch switch)
 * - .git/index - Staging area (changes on add, reset, commit)
 * - .git/refs/heads/ - Local branch tips (changes on commit, fetch)
 * - .git/refs/remotes/ - Remote refs (changes on fetch, pull)
 */

import { watch, type FSWatcher } from 'chokidar'
import { join } from 'node:path'
import { existsSync } from 'node:fs'
import { debug } from '@craft-agent/shared/utils'

// Debounce delay in milliseconds (100ms for rapid git operations like rebase)
const DEBOUNCE_MS = 100

interface GitWatcherOptions {
  debounceMs?: number
  onError?: (error: Error) => void
}

/**
 * Watches .git directory for changes and triggers callback.
 * Per-workspace singleton - create one watcher per workspace directory.
 */
export class GitWatcher {
  private watcher: FSWatcher | null = null
  private debounceTimer: NodeJS.Timeout | null = null
  private readonly debounceMs: number
  private readonly onError?: (error: Error) => void

  constructor(
    private readonly workspaceDir: string,
    private readonly onGitChange: () => void,
    options: GitWatcherOptions = {}
  ) {
    this.debounceMs = options.debounceMs ?? DEBOUNCE_MS
    this.onError = options.onError
  }

  /**
   * Start watching .git paths.
   * @returns true if watching started, false if not a git repo
   */
  start(): boolean {
    const gitDir = join(this.workspaceDir, '.git')

    // Verify .git exists
    if (!existsSync(gitDir)) {
      debug('[GitWatcher] Not a git repository:', this.workspaceDir)
      return false
    }

    // Watch selective paths only - not entire .git directory
    const watchPaths = [
      join(gitDir, 'HEAD'),
      join(gitDir, 'index'),
      join(gitDir, 'refs', 'heads'),
      join(gitDir, 'refs', 'remotes'),
    ]

    this.watcher = watch(watchPaths, {
      persistent: true,
      ignoreInitial: true,      // Don't fire on startup
      depth: 2,                 // Limit recursion in refs/
      awaitWriteFinish: {       // Wait for atomic writes
        stabilityThreshold: 100,
        pollInterval: 50,
      },
    })

    this.watcher
      .on('all', (event, path) => {
        debug('[GitWatcher] File change:', event, path)
        this.handleChange()
      })
      .on('error', (error) => {
        debug('[GitWatcher] Error:', error)
        this.onError?.(error)
      })
      .on('ready', () => {
        debug('[GitWatcher] Ready:', this.workspaceDir)
      })

    return true
  }

  private handleChange(): void {
    // Debounce rapid changes (e.g., during rebase which touches multiple files)
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }
    this.debounceTimer = setTimeout(() => {
      this.debounceTimer = null
      this.onGitChange()
    }, this.debounceMs)
  }

  /**
   * Stop watching and clean up resources.
   */
  stop(): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
      this.debounceTimer = null
    }
    this.watcher?.close()
    this.watcher = null
    debug('[GitWatcher] Stopped:', this.workspaceDir)
  }

  /**
   * Check if watcher is currently active.
   */
  isRunning(): boolean {
    return this.watcher !== null
  }

  /**
   * Get the workspace directory being watched.
   */
  getWorkspaceDir(): string {
    return this.workspaceDir
  }
}
```
  </action>
  <verify>
    - `bun run typecheck:all` passes
    - File exists at `apps/electron/src/main/lib/git-watcher.ts`
    - chokidar appears in `apps/electron/package.json` dependencies
  </verify>
  <done>
    GitWatcher class created with chokidar watching selective .git paths, debouncing enabled
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GIT_STATUS_CHANGED IPC channel and preload bridge</name>
  <files>
    apps/electron/src/shared/types.ts
    apps/electron/src/preload/index.ts
  </files>
  <action>
1. In `apps/electron/src/shared/types.ts`, add the IPC channel:

   Find the `IPC_CHANNELS` object (around line 470) and add after `PR_STATUS`:
   ```typescript
   // Git real-time events (main -> renderer broadcast)
   GIT_STATUS_CHANGED: 'git:statusChanged',  // Payload: workspaceDir string
   ```

2. In `apps/electron/src/shared/types.ts`, add to `ElectronAPI` interface (around line 950):
   ```typescript
   // Git status change listener (for real-time updates)
   onGitStatusChanged(callback: (workspaceDir: string) => void): () => void
   ```

3. In `apps/electron/src/preload/index.ts`, add the listener (near the git methods around line 412):
   ```typescript
   onGitStatusChanged: (callback: (workspaceDir: string) => void) => {
     const handler = (_event: Electron.IpcRendererEvent, workspaceDir: string) => {
       callback(workspaceDir)
     }
     ipcRenderer.on(IPC_CHANNELS.GIT_STATUS_CHANGED, handler)
     return () => {
       ipcRenderer.removeListener(IPC_CHANNELS.GIT_STATUS_CHANGED, handler)
     }
   },
   ```
  </action>
  <verify>
    - `bun run typecheck:all` passes
    - GIT_STATUS_CHANGED exists in IPC_CHANNELS
    - onGitStatusChanged exists in ElectronAPI interface
    - onGitStatusChanged implementation in preload/index.ts
  </verify>
  <done>
    GIT_STATUS_CHANGED IPC channel defined, preload bridge exposes onGitStatusChanged listener
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate GitWatcher into IPC layer with broadcast</name>
  <files>
    apps/electron/src/main/ipc.ts
  </files>
  <action>
1. In `apps/electron/src/main/ipc.ts`, add imports at the top:
   ```typescript
   import { GitWatcher } from './lib/git-watcher'
   ```

2. Add state management for watchers (near other state like configWatchers):
   ```typescript
   // Git file watchers per workspace (workspace directory path -> GitWatcher)
   const gitWatchers = new Map<string, GitWatcher>()
   ```

3. Create a helper function to broadcast git changes:
   ```typescript
   /**
    * Broadcast git status change to all windows.
    * Called by GitWatcher when .git files change.
    */
   function broadcastGitChange(workspaceDir: string): void {
     for (const window of BrowserWindow.getAllWindows()) {
       if (!window.isDestroyed() && !window.webContents.isDestroyed()) {
         window.webContents.send(IPC_CHANNELS.GIT_STATUS_CHANGED, workspaceDir)
       }
     }
   }
   ```

4. Create a function to start/stop git watcher for a workspace:
   ```typescript
   /**
    * Start git file watcher for a workspace directory.
    * Stops any existing watcher for the same directory first.
    */
   function startGitWatcher(workspaceDir: string): void {
     // Stop existing watcher if any
     const existing = gitWatchers.get(workspaceDir)
     if (existing) {
       existing.stop()
       gitWatchers.delete(workspaceDir)
     }

     // Create and start new watcher
     const watcher = new GitWatcher(workspaceDir, () => {
       broadcastGitChange(workspaceDir)
     })

     if (watcher.start()) {
       gitWatchers.set(workspaceDir, watcher)
       ipcLog.debug('[GitWatcher] Started for:', workspaceDir)
     }
   }

   /**
    * Stop git file watcher for a workspace directory.
    */
   function stopGitWatcher(workspaceDir: string): void {
     const watcher = gitWatchers.get(workspaceDir)
     if (watcher) {
       watcher.stop()
       gitWatchers.delete(workspaceDir)
       ipcLog.debug('[GitWatcher] Stopped for:', workspaceDir)
     }
   }
   ```

5. Modify the existing GIT_STATUS handler to start a watcher if not already running:
   Find the `ipcMain.handle(IPC_CHANNELS.GIT_STATUS, ...)` handler and add watcher startup:
   ```typescript
   ipcMain.handle(IPC_CHANNELS.GIT_STATUS, async (_event, dirPath: string) => {
     try {
       const status = await getGitStatus(dirPath)

       // Start git watcher for this directory if it's a git repo and no watcher exists
       if (status.isRepo && !gitWatchers.has(dirPath)) {
         startGitWatcher(dirPath)
       }

       return status
     } catch (error) {
       ipcLog.error('[GIT_STATUS] Unexpected error:', error)
       return { branch: null, isRepo: false, isDetached: false, detachedHead: null }
     }
   })
   ```

6. Add cleanup when workspace is switched (find SWITCH_WORKSPACE handler or window close logic):
   In the app 'before-quit' or window close handler, ensure watchers are cleaned up:
   ```typescript
   // Clean up all git watchers on app quit
   app.on('before-quit', () => {
     for (const watcher of gitWatchers.values()) {
       watcher.stop()
     }
     gitWatchers.clear()
   })
   ```
  </action>
  <verify>
    - `bun run typecheck:all` passes
    - GitWatcher import exists in ipc.ts
    - gitWatchers Map exists
    - broadcastGitChange function exists
    - GIT_STATUS handler starts watcher for git repos
    - Run `bun run electron:dev`, switch to a git repo workspace, run `git checkout -b test-branch`, observe GIT_STATUS_CHANGED event in DevTools console (renderer should log or update)
  </verify>
  <done>
    GitWatcher integrated into IPC layer, starts watching when git status is requested, broadcasts changes to all windows
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Type checking: `bun run typecheck:all`
2. Manual test:
   - Start app: `bun run electron:dev`
   - Open a git repository workspace
   - Open DevTools in renderer (Cmd+Option+I)
   - Add a console.log in renderer to see GIT_STATUS_CHANGED events
   - In terminal, run `git checkout -b test-live-01`
   - Observe that GIT_STATUS_CHANGED event fires within ~100ms of git operation
   - Switch to non-git workspace, verify no watcher errors
   - Quit app, verify clean shutdown (no hanging watchers)
</verification>

<success_criteria>
- chokidar v4.x installed in apps/electron
- GitWatcher class created with selective .git path watching
- GIT_STATUS_CHANGED IPC channel defined and wired through preload
- GitWatcher starts automatically when GIT_STATUS is requested for a git repo
- Changes to .git/HEAD, .git/index, .git/refs/ trigger broadcast
- Type checking passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-updates/05-01-SUMMARY.md`
</output>

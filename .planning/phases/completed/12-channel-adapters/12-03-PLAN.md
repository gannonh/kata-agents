---
phase: 12-channel-adapters
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - packages/shared/src/channels/adapters/whatsapp-adapter.ts
  - packages/shared/src/channels/adapters/index.ts
  - packages/shared/src/channels/__tests__/whatsapp-adapter.test.ts
autonomous: false

must_haves:
  truths:
    - "Bun ws compatibility with Baileys is validated before implementation proceeds"
    - "If Baileys works under Bun: WhatsApp adapter connects and enqueues inbound messages"
    - "If Baileys fails under Bun: WhatsApp adapter is deferred with documented rationale"
    - "WhatsApp adapter skips messages from self (key.fromMe filter)"
    - "WhatsApp adapter converts Baileys message events to ChannelMessage format"
  artifacts:
    - path: "packages/shared/src/channels/adapters/whatsapp-adapter.ts"
      provides: "WhatsAppChannelAdapter implementing ChannelAdapter (if Baileys+Bun works)"
    - path: "packages/shared/src/channels/__tests__/whatsapp-adapter.test.ts"
      provides: "WhatsApp adapter unit tests (if proceeding)"
  key_links:
    - from: "packages/shared/src/channels/adapters/whatsapp-adapter.ts"
      to: "@whiskeysockets/baileys"
      via: "import makeWASocket"
      pattern: "makeWASocket"
    - from: "packages/shared/src/channels/adapters/index.ts"
      to: "whatsapp-adapter.ts"
      via: "createAdapter case 'whatsapp'"
      pattern: "WhatsAppChannelAdapter"
---

<objective>
Validate Baileys compatibility with Bun and, if viable, implement the WhatsApp channel adapter. If Bun's ws polyfill still lacks the events Baileys requires, defer WhatsApp to a later phase.

Purpose: CHAN-02 requires WhatsApp adapter. Research identified confirmed Bun incompatibility with Baileys' ws usage. This plan gates implementation on a compatibility test.
Output: Either a working WhatsApp adapter or a documented deferral decision.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/pending/12-channel-adapters/12-RESEARCH.md
@packages/shared/src/channels/types.ts
@packages/shared/src/channels/adapters/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Baileys + Bun compatibility test</name>
  <files>package.json</files>
  <action>
    Install Baileys and its required dependencies:
    ```bash
    bun add @whiskeysockets/baileys @hapi/boom pino
    ```

    Create a minimal test script at `packages/shared/src/channels/__tests__/baileys-bun-compat.ts` (temporary, not committed):
    ```typescript
    import makeWASocket, { useMultiFileAuthState } from '@whiskeysockets/baileys';
    import pino from 'pino';
    import { mkdtemp, rm } from 'fs/promises';
    import { tmpdir } from 'os';
    import { join } from 'path';

    async function test() {
      const authDir = await mkdtemp(join(tmpdir(), 'baileys-test-'));
      try {
        const { state, saveCreds } = await useMultiFileAuthState(authDir);
        const logger = pino({ level: 'silent' });
        const sock = makeWASocket({
          auth: { creds: state.creds, keys: state.keys },
          logger,
          printQRInTerminal: false,
        });

        // Wait up to 10 seconds for connection attempt
        await new Promise<void>((resolve, reject) => {
          const timeout = setTimeout(() => {
            resolve(); // Timeout means no crash = partial success
          }, 10_000);

          sock.ev.on('connection.update', (update) => {
            clearTimeout(timeout);
            if (update.connection === 'close') {
              // Connection closed is expected (no QR scanned), but if it got this far,
              // ws events are working
              console.log('CONNECTION CLOSED (expected): Baileys ws events work under Bun');
              resolve();
            }
            if (update.qr) {
              console.log('QR CODE RECEIVED: Baileys ws events work under Bun');
              resolve();
            }
          });
        });

        sock.end(undefined);
        console.log('RESULT: Baileys appears compatible with Bun');
      } catch (err) {
        console.log(`RESULT: Baileys INCOMPATIBLE with Bun: ${err}`);
      } finally {
        await rm(authDir, { recursive: true, force: true });
      }
    }

    test();
    ```

    Run: `bun run packages/shared/src/channels/__tests__/baileys-bun-compat.ts`

    Evaluate output:
    - If "Baileys appears compatible" or "QR CODE RECEIVED" or "CONNECTION CLOSED (expected)": proceed to Task 2
    - If "Baileys INCOMPATIBLE" or crashes with ws-related errors: proceed to checkpoint

    Delete the temporary test script after evaluation.
  </action>
  <verify>
    Compatibility test script runs and produces a clear RESULT line.
  </verify>
  <done>
    Baileys + Bun compatibility status is known. Decision gate for Task 2 vs deferral.
  </done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>Proceed with WhatsApp adapter or defer to later phase</decision>
  <context>
    Research identified that Bun's ws polyfill lacks `upgrade` and `unexpected-response` events that Baileys depends on. Task 1 ran a live compatibility test. The result determines whether to implement or defer.

    If Baileys worked under Bun: Proceed to implement WhatsAppChannelAdapter (Task 3).
    If Baileys failed: Three options below.
  </context>
  <options>
    <option id="implement">
      <name>Implement WhatsApp adapter (Baileys works)</name>
      <pros>Delivers CHAN-02 in this phase. Full feature parity.</pros>
      <cons>None if compatibility test passed.</cons>
    </option>
    <option id="defer">
      <name>Defer WhatsApp to later phase</name>
      <pros>No risk. Remove Baileys deps. Focus on Slack quality. Bun may fix ws events in a future release.</pros>
      <cons>CHAN-02 not delivered in Phase 12. Roadmap success criteria #2 unmet.</cons>
    </option>
    <option id="node-child">
      <name>Run WhatsApp adapter as Node.js child process</name>
      <pros>Bypasses Bun limitation. Can be implemented now.</pros>
      <cons>Architectural complexity: daemon (Bun) spawns child (Node.js) for one adapter. IPC overhead. Harder to test.</cons>
    </option>
  </options>
  <resume-signal>Select: implement, defer, or node-child</resume-signal>
</task>

<task type="auto">
  <name>Task 3: WhatsAppChannelAdapter (if proceeding)</name>
  <files>
    packages/shared/src/channels/adapters/whatsapp-adapter.ts
    packages/shared/src/channels/adapters/index.ts
    packages/shared/src/channels/__tests__/whatsapp-adapter.test.ts
  </files>
  <action>
    **Only execute this task if checkpoint decision is "implement".**
    **If decision is "defer": remove Baileys deps (`bun remove @whiskeysockets/baileys @hapi/boom pino`), update SUMMARY with deferral rationale, skip this task.**
    **If decision is "node-child": this task requires redesign. Create a follow-up plan.**

    **Create `packages/shared/src/channels/adapters/whatsapp-adapter.ts`:**

    WhatsAppChannelAdapter implements ChannelAdapter with `type = 'subscribe'`.

    Properties:
    - `readonly id: string`
    - `readonly name = 'WhatsApp'`
    - `readonly type = 'subscribe' as const`
    - `private sock: ReturnType<typeof makeWASocket> | null`
    - `private healthy: boolean`
    - `private lastErrorMsg: string | null`

    `configure(authStatePath: string)`: Store the path where Baileys auth state will be persisted.

    `start(config, onMessage)`:
    1. Store config.slug as this.id.
    2. Load auth state: `const { state, saveCreds } = await useMultiFileAuthState(authStatePath)`.
    3. Create socket:
       ```typescript
       this.sock = makeWASocket({
         auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, logger) },
         logger: pino({ level: 'silent' }),
         printQRInTerminal: false,
       });
       ```
    4. Register event handlers:
       - `connection.update`: Track connection state. On close, check DisconnectReason. If not loggedOut, attempt reconnect (call start again). On open, set healthy = true. On qr, emit qr data via a callback or store for later retrieval.
       - `messages.upsert`: For each message where `type === 'notify'` and `!msg.key.fromMe` and `msg.message` exists:
         - Extract text: check `msg.message.conversation` or `msg.message.extendedTextMessage?.text`
         - Convert to ChannelMessage:
           ```typescript
           {
             id: msg.key.id!,
             channelId: this.id,
             source: msg.key.remoteJid!,
             timestamp: (msg.messageTimestamp as number) * 1000,
             content: extractedText,
             metadata: { jid: msg.key.remoteJid, participant: msg.key.participant },
             replyTo: msg.message.extendedTextMessage?.contextInfo?.stanzaId ? {
               threadId: msg.key.remoteJid!,
               messageId: msg.message.extendedTextMessage.contextInfo.stanzaId,
             } : undefined,
           }
           ```
         - Call onMessage.
       - `creds.update`: Call saveCreds.
    5. Set healthy = true after socket creation (actual health determined by connection.update).

    `stop()`: Call `this.sock?.end(undefined)`, set sock to null, healthy to false.
    `isHealthy()`: return this.healthy.
    `getLastError()`: return this.lastErrorMsg.

    **Update `packages/shared/src/channels/adapters/index.ts`:**
    Add `case 'whatsapp': return new WhatsAppChannelAdapter()` to createAdapter.

    **Tests (`packages/shared/src/channels/__tests__/whatsapp-adapter.test.ts`):**
    Mock `@whiskeysockets/baileys` module. Tests:
    - start() creates socket with auth state
    - messages.upsert handler skips fromMe messages
    - messages.upsert handler converts to ChannelMessage
    - messages.upsert handler extracts text from conversation and extendedTextMessage
    - connection.update handler sets healthy on open
    - stop() calls end and sets healthy to false
  </action>
  <verify>
    `bun test packages/shared/src/channels/__tests__/whatsapp-adapter.test.ts` passes.
    `bun run typecheck:all` passes.
    `bun test` — full suite passes.
  </verify>
  <done>
    WhatsApp adapter connects via Baileys, filters self-messages, converts to ChannelMessage format. Registered in adapter factory.
  </done>
</task>

</tasks>

<verification>
- Baileys + Bun compatibility result documented
- If proceeding: `bun test packages/shared/src/channels/` passes with WhatsApp adapter tests
- If deferred: Baileys deps removed, deferral documented in SUMMARY
- `bun run typecheck:all` passes
- `bun test` — full suite passes
</verification>

<success_criteria>
- Bun + Baileys compatibility conclusively determined
- If compatible: WhatsApp adapter enqueues inbound messages (CHAN-02)
- If incompatible: clean deferral with deps removed and rationale documented
</success_criteria>

<output>
After completion, create `.planning/phases/pending/12-channel-adapters/12-03-SUMMARY.md`
</output>

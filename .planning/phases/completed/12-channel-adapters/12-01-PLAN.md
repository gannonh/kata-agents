---
phase: 12-channel-adapters
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/channels/trigger-matcher.ts
  - packages/shared/src/channels/session-resolver.ts
  - packages/shared/src/channels/index.ts
  - packages/shared/src/channels/__tests__/trigger-matcher.test.ts
  - packages/shared/src/channels/__tests__/session-resolver.test.ts
  - packages/shared/src/daemon/message-queue.ts
  - packages/shared/src/daemon/__tests__/message-queue.test.ts
autonomous: true

must_haves:
  truths:
    - "TriggerMatcher with no patterns matches all messages"
    - "TriggerMatcher with patterns matches only messages containing at least one pattern"
    - "TriggerMatcher patterns are case-insensitive"
    - "ChannelSessionResolver produces deterministic session keys for the same input"
    - "ChannelSessionResolver produces different keys for different threads in the same channel"
    - "ChannelSessionResolver falls back to channelSourceId when threadId is undefined"
    - "Polling state table stores and retrieves last-known timestamps per channel adapter"
  artifacts:
    - path: "packages/shared/src/channels/trigger-matcher.ts"
      provides: "TriggerMatcher class"
      exports: ["TriggerMatcher"]
    - path: "packages/shared/src/channels/session-resolver.ts"
      provides: "ChannelSessionResolver class"
      exports: ["ChannelSessionResolver"]
    - path: "packages/shared/src/channels/__tests__/trigger-matcher.test.ts"
      provides: "TriggerMatcher unit tests"
    - path: "packages/shared/src/channels/__tests__/session-resolver.test.ts"
      provides: "ChannelSessionResolver unit tests"
  key_links:
    - from: "packages/shared/src/channels/index.ts"
      to: "trigger-matcher.ts, session-resolver.ts"
      via: "barrel re-exports"
      pattern: "export.*TriggerMatcher|ChannelSessionResolver"
    - from: "packages/shared/src/daemon/message-queue.ts"
      to: "SQLite polling_state table"
      via: "getPollingState/setPollingState methods"
      pattern: "polling_state"
---

<objective>
Build the shared channel infrastructure: TriggerMatcher for filtering inbound messages by configurable patterns, ChannelSessionResolver for deterministic thread-to-session mapping, and a polling state persistence table in MessageQueue for adapter restart resilience.

Purpose: These are the building blocks that both Slack and WhatsApp adapters depend on. TDD ensures the matching and mapping logic is correct before adapters consume it.
Output: Two tested classes exported from @craft-agent/shared/channels, plus polling state persistence in MessageQueue.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/12-channel-adapters/12-RESEARCH.md
@packages/shared/src/channels/types.ts
@packages/shared/src/channels/index.ts
@packages/shared/src/daemon/message-queue.ts
@packages/shared/src/daemon/__tests__/message-queue.test.ts
</context>

<tasks>

<feature>
  <name>Feature 1: TriggerMatcher</name>
  <files>packages/shared/src/channels/trigger-matcher.ts, packages/shared/src/channels/__tests__/trigger-matcher.test.ts</files>
  <behavior>
    TriggerMatcher takes an array of regex pattern strings in its constructor and compiles them to RegExp with case-insensitive flag.

    Cases:
    - new TriggerMatcher([]).matches("anything") -> true (no patterns = match all)
    - new TriggerMatcher(["@kata"]).matches("hey @kata help") -> true
    - new TriggerMatcher(["@kata"]).matches("hello world") -> false
    - new TriggerMatcher(["@kata", "!help"]).matches("!help me") -> true (any pattern matches)
    - new TriggerMatcher(["@KATA"]).matches("hey @kata") -> true (case insensitive)
    - new TriggerMatcher(["^important"]).matches("important update") -> true (regex anchors work)
    - new TriggerMatcher(["^important"]).matches("not important") -> false
    - Invalid regex pattern in constructor throws descriptive error
  </behavior>
  <implementation>
    Class with private `patterns: RegExp[]` field. Constructor compiles each string to `new RegExp(pattern, 'i')`, wrapped in try/catch that rethrows with the invalid pattern string in the message. `matches(content: string): boolean` returns `true` if patterns is empty, otherwise `this.patterns.some(p => p.test(content))`.

    Export from `packages/shared/src/channels/index.ts` barrel. This is a runtime export (not type-only).
  </implementation>
</feature>

<feature>
  <name>Feature 2: ChannelSessionResolver</name>
  <files>packages/shared/src/channels/session-resolver.ts, packages/shared/src/channels/__tests__/session-resolver.test.ts</files>
  <behavior>
    ChannelSessionResolver.resolveSessionKey(channelSlug, workspaceId, threadId, channelSourceId) produces a deterministic session key string.

    Format: daemon-{channelSlug}-{hash12} where hash12 is first 12 hex chars of SHA-256 of "{channelSlug}:{workspaceId}:{threadKey}". threadKey is threadId if defined, otherwise channelSourceId.

    Cases:
    - resolveSessionKey("slack", "ws1", "thread123", "C123") -> "daemon-slack-{hash of slack:ws1:thread123}"
    - resolveSessionKey("slack", "ws1", undefined, "C123") -> "daemon-slack-{hash of slack:ws1:C123}"
    - Same inputs always produce same output (deterministic)
    - Different threadIds produce different keys
    - Different workspaceIds produce different keys
    - Different channelSlugs produce different keys
    - Output length is always "daemon-{slug}-" + 12 hex chars
  </behavior>
  <implementation>
    Import `createHash` from `crypto`. Single static method `resolveSessionKey` (or make it a standalone function, no class state needed). Use `createHash('sha256').update(input).digest('hex').slice(0, 12)`.

    Export from `packages/shared/src/channels/index.ts` barrel. Runtime export.
  </implementation>
</feature>

<task type="auto">
  <name>Task 3: Add polling state persistence to MessageQueue</name>
  <files>packages/shared/src/daemon/message-queue.ts, packages/shared/src/daemon/__tests__/message-queue.test.ts</files>
  <action>
    Add a `polling_state` table to MessageQueue for persisting adapter polling cursors across restarts.

    Schema:
    ```sql
    CREATE TABLE IF NOT EXISTS polling_state (
      adapter_id TEXT NOT NULL,
      channel_source_id TEXT NOT NULL,
      last_timestamp TEXT NOT NULL,
      updated_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
      PRIMARY KEY (adapter_id, channel_source_id)
    )
    ```

    Add two new methods to MessageQueue:
    - `getPollingState(adapterId: string, channelSourceId: string): string | null` — returns last_timestamp or null
    - `setPollingState(adapterId: string, channelSourceId: string, lastTimestamp: string): void` — upserts via INSERT OR REPLACE

    Use prepared statements stored as private fields, same pattern as existing enqueue/dequeue statements.

    Add tests (3-4):
    - getPollingState returns null for unknown adapter/channel
    - setPollingState stores and getPollingState retrieves the timestamp
    - setPollingState overwrites previous value for same adapter/channel
    - Different adapter/channel combos are independent
  </action>
  <verify>
    `bun test packages/shared/src/daemon/__tests__/message-queue.test.ts` — all existing + new tests pass.
    `bun run typecheck:all` passes.
  </verify>
  <done>
    MessageQueue has getPollingState/setPollingState methods with prepared statements and passing tests. Adapters can persist their polling cursors for restart resilience.
  </done>
</task>

</tasks>

<verification>
- `bun test packages/shared/src/channels/` — all trigger-matcher and session-resolver tests pass
- `bun test packages/shared/src/daemon/__tests__/message-queue.test.ts` — all tests pass including new polling state tests
- `bun run typecheck:all` — zero errors
- `bun test` — full suite passes, no regressions
- Verify barrel exports: TriggerMatcher and ChannelSessionResolver importable from `@craft-agent/shared/channels`
</verification>

<success_criteria>
- TriggerMatcher correctly filters messages by regex patterns (empty = match all)
- ChannelSessionResolver produces deterministic, collision-resistant session keys
- MessageQueue persists polling state across close/reopen cycles
- All new code has unit tests with TDD red-green-refactor commits
</success_criteria>

<output>
After completion, create `.planning/phases/pending/12-channel-adapters/12-01-SUMMARY.md`
</output>

---
phase: 02-unit-test-coverage
plan: 03
type: execute
wave: 1
depends_on: []
gap_closure: true
files_modified:
  - bunfig.toml
  - scripts/coverage-summary.ts
  - package.json
  - .github/workflows/ci.yml
autonomous: true

must_haves:
  truths:
    - "Running `bun run test:coverage:summary` outputs module-level coverage aggregates"
    - "CI fails when overall coverage drops below 70% functions"
    - "bunfig.toml contains coverageThreshold configuration"
  artifacts:
    - path: "scripts/coverage-summary.ts"
      provides: "Coverage aggregation script"
      min_lines: 50
    - path: "bunfig.toml"
      provides: "Coverage thresholds"
      contains: "coverageThreshold"
  key_links:
    - from: "scripts/coverage-summary.ts"
      to: "bun run test:coverage"
      via: "parses coverage JSON output"
      pattern: "coverageReporter"
---

<objective>
Add aggressive coverage thresholds with automated enforcement.

Purpose: UAT revealed that coverage configuration has no thresholds, no automated summaries, and static documentation that becomes stale. This plan adds CI-enforced coverage gates.

Output: Coverage thresholds in bunfig.toml, summary script, CI integration. Delete stale COVERAGE.md.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/phases/completed/02-unit-test-coverage/02-UAT.md
@bunfig.toml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add coverage thresholds to bunfig.toml</name>
  <files>bunfig.toml</files>
  <action>
Update bunfig.toml to add coverage thresholds. Add to the existing [test] section:

```toml
[test]
preload = ["./packages/shared/src/network-interceptor.ts"]
coverageSkipTestFiles = true
coveragePathIgnorePatterns = [
  "**/release/**",
  "**/node_modules/**",
  "**/*.d.ts"
]

# Coverage thresholds - CI fails if below these targets
[test.coverageThreshold]
line = 65
function = 70
statement = 65
```

Note: Bun's coverageThreshold applies to overall coverage. Per-directory thresholds would need custom script enforcement.
  </action>
  <verify>
Run `bun test --coverage 2>&1 | tail -20` and verify thresholds are mentioned in output.
  </verify>
  <done>bunfig.toml contains coverageThreshold with 70% function target</done>
</task>

<task type="auto">
  <name>Task 2: Create coverage summary script</name>
  <files>scripts/coverage-summary.ts</files>
  <action>
Create `scripts/coverage-summary.ts` that:
1. Runs `bun test --coverage` and captures output
2. Parses the coverage table from stdout
3. Aggregates by directory (packages/shared, packages/mermaid, packages/ui, apps/electron)
4. Outputs a summary table
5. Exits with error code if any area is below its threshold

```typescript
#!/usr/bin/env bun
/**
 * Coverage Summary Script
 * Aggregates bun test coverage output by module area.
 *
 * Usage: bun run scripts/coverage-summary.ts
 */

import { $ } from "bun";

interface CoverageEntry {
  file: string;
  functions: number;
  lines: number;
}

interface AreaSummary {
  area: string;
  files: number;
  avgFunctions: number;
  avgLines: number;
  target: number;
  pass: boolean;
}

// Aggressive targets from UAT
const THRESHOLDS: Record<string, number> = {
  "packages/mermaid": 95,
  "packages/shared": 60,
  "packages/ui": 80,
  "apps/electron": 70,
};

const OVERALL_THRESHOLD = 70;

async function main() {
  console.log("Running coverage analysis...\n");

  // Run coverage and capture output
  const result = await $`bun test --coverage ./packages/ ./apps/electron/src/renderer/lib/ 2>&1`.text();

  // Parse the coverage table (lines starting with file paths and containing |)
  const lines = result.split("\n");
  const entries: CoverageEntry[] = [];

  let inTable = false;
  for (const line of lines) {
    // Detect table start
    if (line.includes("File") && line.includes("% Funcs") && line.includes("% Lines")) {
      inTable = true;
      continue;
    }

    // Skip separator lines
    if (line.startsWith("---")) continue;

    // Parse data rows
    if (inTable && line.includes("|")) {
      const parts = line.split("|").map(p => p.trim());
      if (parts.length >= 3 && parts[0] && !parts[0].startsWith("All files")) {
        const file = parts[0];
        const funcs = parseFloat(parts[1]) || 0;
        const lns = parseFloat(parts[2]) || 0;
        entries.push({ file, functions: funcs, lines: lns });
      }
    }

    // Detect table end
    if (inTable && line.trim() === "") {
      inTable = false;
    }
  }

  // Aggregate by area
  const areas = new Map<string, CoverageEntry[]>();

  for (const entry of entries) {
    let area = "other";
    if (entry.file.startsWith("packages/mermaid")) area = "packages/mermaid";
    else if (entry.file.startsWith("packages/shared")) area = "packages/shared";
    else if (entry.file.startsWith("packages/ui")) area = "packages/ui";
    else if (entry.file.startsWith("apps/electron")) area = "apps/electron";

    if (!areas.has(area)) areas.set(area, []);
    areas.get(area)!.push(entry);
  }

  // Calculate summaries
  const summaries: AreaSummary[] = [];
  let totalFuncs = 0;
  let totalLines = 0;
  let totalFiles = 0;

  for (const [area, files] of areas) {
    if (area === "other") continue;

    const avgFuncs = files.reduce((sum, f) => sum + f.functions, 0) / files.length;
    const avgLines = files.reduce((sum, f) => sum + f.lines, 0) / files.length;
    const target = THRESHOLDS[area] || 50;

    summaries.push({
      area,
      files: files.length,
      avgFunctions: Math.round(avgFuncs * 100) / 100,
      avgLines: Math.round(avgLines * 100) / 100,
      target,
      pass: avgFuncs >= target,
    });

    totalFuncs += files.reduce((sum, f) => sum + f.functions, 0);
    totalLines += files.reduce((sum, f) => sum + f.lines, 0);
    totalFiles += files.length;
  }

  const overallFuncs = totalFiles > 0 ? totalFuncs / totalFiles : 0;
  const overallLines = totalFiles > 0 ? totalLines / totalFiles : 0;

  // Output summary
  console.log("┌─────────────────────────────────────────────────────────────┐");
  console.log("│                    COVERAGE SUMMARY                         │");
  console.log("├──────────────────┬───────┬──────────┬─────────┬────────┬────┤");
  console.log("│ Area             │ Files │ Funcs %  │ Lines % │ Target │ ✓  │");
  console.log("├──────────────────┼───────┼──────────┼─────────┼────────┼────┤");

  for (const s of summaries.sort((a, b) => a.area.localeCompare(b.area))) {
    const status = s.pass ? "✓" : "✗";
    const areaCol = s.area.padEnd(16);
    const filesCol = String(s.files).padStart(5);
    const funcsCol = s.avgFunctions.toFixed(1).padStart(7) + "%";
    const linesCol = s.avgLines.toFixed(1).padStart(6) + "%";
    const targetCol = (s.target + "%").padStart(6);
    console.log(`│ ${areaCol} │${filesCol} │ ${funcsCol} │ ${linesCol} │${targetCol} │ ${status}  │`);
  }

  console.log("├──────────────────┼───────┼──────────┼─────────┼────────┼────┤");
  const overallPass = overallFuncs >= OVERALL_THRESHOLD;
  const overallStatus = overallPass ? "✓" : "✗";
  console.log(`│ OVERALL          │${String(totalFiles).padStart(5)} │ ${overallFuncs.toFixed(1).padStart(7)}% │ ${overallLines.toFixed(1).padStart(6)}% │${(OVERALL_THRESHOLD + "%").padStart(6)} │ ${overallStatus}  │`);
  console.log("└──────────────────┴───────┴──────────┴─────────┴────────┴────┘");

  // Check for failures
  const failures = summaries.filter(s => !s.pass);
  if (failures.length > 0 || !overallPass) {
    console.log("\n❌ Coverage below threshold:");
    for (const f of failures) {
      console.log(`   - ${f.area}: ${f.avgFunctions.toFixed(1)}% < ${f.target}% target`);
    }
    if (!overallPass) {
      console.log(`   - Overall: ${overallFuncs.toFixed(1)}% < ${OVERALL_THRESHOLD}% target`);
    }
    process.exit(1);
  }

  console.log("\n✓ All coverage thresholds met");
  process.exit(0);
}

main().catch(err => {
  console.error("Coverage analysis failed:", err);
  process.exit(1);
});
```
  </action>
  <verify>
Run `bun run scripts/coverage-summary.ts` and verify it outputs a formatted table with area summaries.
  </verify>
  <done>Coverage summary script outputs module-level aggregates with pass/fail status</done>
</task>

<task type="auto">
  <name>Task 3: Add npm script for coverage summary</name>
  <files>package.json</files>
  <action>
Add to package.json scripts section:

```json
"test:coverage:summary": "bun run scripts/coverage-summary.ts"
```

Place it after the existing test:coverage script.
  </action>
  <verify>Run `bun run test:coverage:summary` and verify it works</verify>
  <done>npm script added for coverage summary</done>
</task>

<task type="auto">
  <name>Task 4: Update CI workflow</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Update `.github/workflows/ci.yml` to add coverage check step. Add after the existing test step:

```yaml
      - name: Check coverage thresholds
        run: bun run test:coverage:summary
```

This will fail the CI if coverage drops below thresholds.
  </action>
  <verify>Read .github/workflows/ci.yml and verify the coverage step is present</verify>
  <done>CI workflow runs coverage check</done>
</task>

<task type="auto">
  <name>Task 5: Delete stale COVERAGE.md</name>
  <files>.planning/COVERAGE.md</files>
  <action>
Delete `.planning/COVERAGE.md` - it's replaced by the automated summary script.

```bash
rm .planning/COVERAGE.md
```
  </action>
  <verify>Confirm .planning/COVERAGE.md no longer exists</verify>
  <done>Stale documentation removed</done>
</task>

</tasks>

<verification>
1. `bun run test:coverage:summary` outputs formatted table with area summaries
2. bunfig.toml contains coverageThreshold with 70% function target
3. CI workflow has coverage check step
4. .planning/COVERAGE.md is deleted
</verification>

<success_criteria>
1. Coverage summary shows pass/fail per area
2. CI will fail if coverage drops below 70% overall
3. Aggressive per-area targets documented in script
4. No stale documentation to maintain
</success_criteria>

<output>
After completion, create `.planning/phases/completed/02-unit-test-coverage/02-03-SUMMARY.md`
</output>

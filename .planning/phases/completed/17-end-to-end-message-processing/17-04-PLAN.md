---
phase: 17-end-to-end-message-processing
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/electron/src/main/sessions.ts
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Session shows conversation history from headless processing"
    - "Daemon sessions don't crash renderer on workspace load"
  artifacts:
    - path: apps/electron/src/main/sessions.ts
      what: "sendMessageHeadless persists user message and assistant response to session JSONL"
  key_links: []
---

<objective>
Add message persistence to `sendMessageHeadless()` so headless-processed channel sessions display conversation history and load without crashing the renderer.

Purpose: Gap 2 — `sendMessageHeadless()` runs the agent but does not write user or assistant messages to the session's messages array or JSONL storage. This means `messageCount` stays 0 and no conversation history is visible. Gap 4 — the SDK creates internal state files in the session directory during headless execution, but without matching JSONL message data the renderer crashes when loading the workspace. Persisting messages fixes both gaps because the JSONL file will contain valid message data, and `messageCount` will be > 0.

Output: Modified `sendMessageHeadless()` in sessions.ts.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/phases/completed/17-end-to-end-message-processing/17-UAT.md
@apps/electron/src/main/sessions.ts (lines 2422-2457, sendMessageHeadless)
@apps/electron/src/main/sessions.ts (lines 2540-2643, sendMessage — reference for persistence pattern)
@apps/electron/src/main/sessions.ts (lines 3307-3338, processEvent text_complete — reference for assistant message creation)
@apps/electron/src/main/sessions.ts (lines 942-985, persistSession)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Persist user and assistant messages in sendMessageHeadless</name>
  <files>apps/electron/src/main/sessions.ts</files>
  <action>
Modify `sendMessageHeadless()` (lines 2422-2457) to write user and assistant messages to `managed.messages` before calling `persistSession()`. This mirrors the persistence behavior of `sendMessage()` without the renderer IPC events (headless sessions intentionally skip IPC broadcasts).

Replace the current `sendMessageHeadless` method with:

```typescript
async sendMessageHeadless(sessionId: string, content: string): Promise<string> {
  const managed = this.sessions.get(sessionId)
  if (!managed) throw new Error(`Session ${sessionId} not found`)

  const agent = await this.getOrCreateAgent(managed)

  // Load sources for context (same as sendMessage but skip renderer events)
  const workspaceRootPath = managed.workspace.rootPath
  const allSources = loadAllSources(workspaceRootPath)
  agent.setAllSources(allSources)

  if (managed.enabledSourceSlugs?.length) {
    const sources = getSourcesBySlugs(workspaceRootPath, managed.enabledSourceSlugs)
    const sessionPath = getSessionStoragePath(workspaceRootPath, sessionId)
    const { mcpServers, apiServers } = await buildServersFromSources(sources, sessionPath)
    const intendedSlugs = sources.filter(s => s.config.enabled && s.config.isAuthenticated).map(s => s.config.slug)
    agent.setSourceServers(mcpServers, apiServers, intendedSlugs)
  }

  // Persist user message (mirrors sendMessage pattern)
  const userMessage: Message = {
    id: generateMessageId(),
    role: 'user',
    content,
    timestamp: Date.now(),
  }
  managed.messages.push(userMessage)
  managed.lastMessageAt = Date.now()

  // Collect final assistant text from the chat generator
  let responseText = ''
  const chatGenerator = agent.chat(content)

  for await (const event of chatGenerator) {
    // Capture the final assistant text blocks
    if (event.type === 'text_complete' && event.text) {
      responseText = event.text
    }
  }

  // Persist assistant response message
  if (responseText) {
    const assistantMessage: Message = {
      id: generateMessageId(),
      role: 'assistant',
      content: responseText,
      timestamp: Date.now(),
    }
    managed.messages.push(assistantMessage)
  }

  // Persist session state after headless execution
  // Messages array now includes user + assistant messages, so
  // messageCount will be correctly computed in the JSONL header
  this.persistSession(managed)

  sessionLog.info(`Headless message processed for ${sessionId}: ${responseText.length} chars`)
  return responseText
}
```

Key changes from the original:
1. Creates and pushes a `userMessage` to `managed.messages` before calling `agent.chat()`.
2. Sets `managed.lastMessageAt` to current timestamp.
3. Creates and pushes an `assistantMessage` to `managed.messages` after collecting the response.
4. The existing `this.persistSession(managed)` call now writes a session with actual messages, so `messageCount` will be > 0 in the JSONL header.
5. No IPC events are broadcast (intentional for headless sessions).
6. `generateMessageId` is already imported at line 48.

This resolves both Gap 2 (conversation history visible) and Gap 4 (renderer crash) because:
- Gap 2: Messages are persisted to JSONL, so the session list shows `messageCount > 0` and loading the session shows conversation history.
- Gap 4: The JSONL file has valid message data consistent with the SDK state files, so the renderer can parse the session list without crashing.
  </action>
  <verify>
1. Run `bun run typecheck:all` — confirm no type errors.
2. Run `bun run lint:electron` — confirm no lint errors.
3. Verify that `Message` type (imported at line 48) supports the fields used: `id`, `role`, `content`, `timestamp`.
4. Verify that `generateMessageId()` is available (imported at line 48).
5. Confirm the method signature and return type are unchanged (`Promise<string>`).
  </verify>
  <done>
`sendMessageHeadless()` persists both user and assistant messages to `managed.messages` before calling `persistSession()`. The JSONL file will contain valid conversation data with correct `messageCount`. Headless sessions will display conversation history in the UI and will not crash the renderer on workspace load.
  </done>
</task>

</tasks>

<verification>
- `bun run typecheck:all` passes
- `bun run lint:electron` passes
- The `sendMessageHeadless` method adds exactly 2 messages (1 user, 1 assistant when response is non-empty) to `managed.messages`
- `persistSession` is called after messages are added, ensuring the JSONL header's `messageCount` reflects the actual message count
- No renderer IPC events are broadcast (headless sessions are intentionally silent)
</verification>

<success_criteria>
- Headless-processed sessions show user and assistant messages when loaded in the renderer
- `messageCount` in the JSONL header matches actual message count (no longer 0)
- Renderer does not crash when loading a workspace that contains headless-processed sessions
- No regressions in typecheck or lint
</success_criteria>

<output>
After completion, create `.planning/phases/completed/17-end-to-end-message-processing/17-04-SUMMARY.md`
</output>

---
phase: 17-end-to-end-message-processing
plan: 02
type: execute
wave: 2
depends_on:
  - 17-01
files_modified:
  - apps/electron/src/main/sessions.ts
  - apps/electron/src/main/index.ts
autonomous: true
must_haves:
  truths:
    - SessionManager has processDaemonMessage(workspaceId, sessionKey, content, channelInfo) that returns a Promise<string>
    - processDaemonMessage creates or reuses a session by matching sessionKey against session names
    - New daemon sessions use safe permission mode and workspace default working directory
    - New daemon sessions include channel attribution (adapter, slug)
    - SessionManager has sendMessageHeadless(sessionId, content) that runs CraftAgent.chat() and collects final text without IPC to renderer
    - index.ts handles process_message DaemonEvent by calling processDaemonMessage and sending message_processed command back
    - Errors in message processing result in message_processed with success false and error string
  artifacts:
    - apps/electron/src/main/sessions.ts with processDaemonMessage() and sendMessageHeadless() methods
    - apps/electron/src/main/index.ts with process_message event handler in daemon onEvent callback
  key_links:
    - .planning/phases/pending/17-end-to-end-message-processing/17-RESEARCH.md
    - .planning/phases/pending/17-end-to-end-message-processing/17-01-PLAN.md
    - apps/electron/src/main/sessions.ts
    - apps/electron/src/main/index.ts
    - apps/electron/src/main/daemon-manager.ts
---

<objective>
Wire daemon message processing through the Electron main process: SessionManager creates/reuses sessions for channel messages, runs CraftAgent headless, and returns response text. The index.ts event handler bridges the daemon's process_message events to SessionManager and sends message_processed commands back.

Purpose: Completes the end-to-end flow. Inbound channel messages trigger agent processing; responses flow back to the daemon for outbound delivery.

Output: Two new SessionManager methods and a daemon event handler in index.ts.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/phases/pending/17-end-to-end-message-processing/17-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md

@apps/electron/src/main/sessions.ts (read key sections: ManagedSession interface, createSession, getOrCreateAgent, sendMessage)
@apps/electron/src/main/index.ts (read DaemonManager creation block, lines 321-348)
@apps/electron/src/main/daemon-manager.ts
@packages/core/src/types/daemon.ts (after Plan 01 modifications)
@packages/shared/src/channels/session-resolver.ts
@apps/electron/src/shared/types.ts (Session type, CreateSessionOptions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sendMessageHeadless() to SessionManager</name>
  <files>
    apps/electron/src/main/sessions.ts
  </files>
  <action>
Add a new method `sendMessageHeadless` to the `SessionManager` class. Place it near the existing `sendMessage` method. This method runs the agent without emitting IPC events to the renderer.

```typescript
/**
 * Run agent chat headlessly (no IPC events to renderer).
 * Used by daemon message processing where there is no active UI session.
 * Returns the final assistant text response.
 */
async sendMessageHeadless(sessionId: string, content: string): Promise<string> {
  const managed = this.sessions.get(sessionId)
  if (!managed) throw new Error(`Session ${sessionId} not found`)

  const agent = await this.getOrCreateAgent(managed)

  // Load sources for context (same as sendMessage but skip renderer events)
  const workspaceRootPath = managed.workspace.rootPath
  const allSources = loadAllSources(workspaceRootPath)
  agent.setAllSources(allSources)

  if (managed.enabledSourceSlugs?.length) {
    const sources = getSourcesBySlugs(workspaceRootPath, managed.enabledSourceSlugs)
    const sessionPath = getSessionStoragePath(workspaceRootPath, sessionId)
    const { mcpServers, apiServers } = await buildServersFromSources(sources, sessionPath)
    const intendedSlugs = sources.filter(s => s.config.enabled && s.config.isAuthenticated).map(s => s.config.slug)
    agent.setSourceServers(mcpServers, apiServers, intendedSlugs)
  }

  // Collect final assistant text from the chat generator
  let responseText = ''
  const chatGenerator = agent.chat(content)

  for await (const event of chatGenerator) {
    // Capture the final assistant text blocks
    if (event.type === 'assistant' && event.message?.content) {
      for (const block of event.message.content) {
        if (block.type === 'text') {
          responseText = block.text
        }
      }
    }
  }

  // Persist session state after headless execution
  this.persistSession(managed)

  sessionLog.info(`Headless message processed for ${sessionId}: ${responseText.length} chars`)
  return responseText
}
```

**Key design decisions:**
- Use `agent.chat(content)` async generator (same as sendMessage)
- Iterate all events but only capture `assistant` message text blocks. The last `text` block in the last `assistant` event is the final response.
- Do NOT emit any IPC events (no `sendEvent` calls)
- Do NOT add the user message to `managed.messages` (headless sessions don't maintain UI state). The SDK handles conversation history internally via sdkSessionId.
- DO persist session after execution so the SDK session state is saved
- Skip permission handling. Daemon sessions use `safe` mode (read-only) so no permission prompts can occur.

Note: `buildServersFromSources` is a module-level function already available in sessions.ts. `loadAllSources`, `getSourcesBySlugs`, `getSessionStoragePath` are already imported. `agent.chat()` returns `AsyncGenerator<AgentEvent>`.

Check the `AgentEvent` type to find the correct event shape for capturing assistant text. The SDK emits events with `type: 'assistant'` containing `message.content` array of content blocks. The final text is in the last such event. If the event type names differ, look at the existing `sendMessage` method's event handling loop for the pattern used to extract assistant text. Match that pattern.
  </action>
  <verify>
Run `bun run typecheck:all`. The new method compiles and matches the CraftAgent async generator event types.
  </verify>
  <done>
- sendMessageHeadless() added to SessionManager
- Runs CraftAgent.chat() and collects final assistant text
- No IPC events emitted to renderer
- Session state persisted after execution
- typecheck passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add processDaemonMessage() to SessionManager</name>
  <files>
    apps/electron/src/main/sessions.ts
  </files>
  <action>
Add a `processDaemonMessage` method to the `SessionManager` class. Place it after `sendMessageHeadless`.

```typescript
/**
 * Process an inbound daemon channel message.
 * Creates or reuses a session identified by sessionKey, then runs the agent headlessly.
 * Returns the agent's text response.
 */
async processDaemonMessage(
  workspaceId: string,
  sessionKey: string,
  content: string,
  channelInfo: { adapter: string; slug: string; displayName?: string },
): Promise<string> {
  const workspace = getWorkspaceByNameOrId(workspaceId)
  if (!workspace) throw new Error(`Workspace ${workspaceId} not found`)

  // Find existing session by matching name === sessionKey
  let sessionId: string | undefined
  for (const [id, managed] of this.sessions) {
    if (managed.name === sessionKey && managed.workspace.id === workspaceId) {
      sessionId = id
      break
    }
  }

  // If not found in memory, check persisted sessions
  if (!sessionId) {
    const storedSessions = listStoredSessions(workspace.rootPath)
    const existing = storedSessions.find(s => s.name === sessionKey)
    if (existing) {
      // Load the session into memory
      const loaded = loadStoredSession(workspace.rootPath, existing.id)
      if (loaded) {
        const managed: ManagedSession = {
          id: loaded.id,
          workspace,
          agent: null,
          messages: loaded.messages?.map(m => ({
            id: m.id,
            role: m.role,
            content: m.content,
            timestamp: m.timestamp,
          })) ?? [],
          isProcessing: false,
          lastMessageAt: loaded.lastMessageAt ?? loaded.lastUsedAt ?? Date.now(),
          streamingText: '',
          processingGeneration: 0,
          isFlagged: false,
          permissionMode: 'safe',
          sdkSessionId: loaded.sdkSessionId,
          workingDirectory: loaded.workingDirectory,
          sdkCwd: loaded.sdkCwd,
          channel: { adapter: channelInfo.adapter, slug: channelInfo.slug, displayName: channelInfo.displayName },
          messageQueue: [],
          backgroundShellCommands: new Map(),
          messagesLoaded: true,
        }
        this.sessions.set(loaded.id, managed)
        sessionId = loaded.id
      }
    }
  }

  // Create new session if no match found
  if (!sessionId) {
    const session = await this.createSession(workspaceId, {
      permissionMode: 'safe',
      workingDirectory: 'user_default',
    })
    sessionId = session.id

    // Set channel attribution and session name (sessionKey) on the managed session
    const managed = this.sessions.get(sessionId)!
    managed.name = sessionKey
    managed.channel = {
      adapter: channelInfo.adapter,
      slug: channelInfo.slug,
      displayName: channelInfo.displayName,
    }

    // Persist the name and channel info
    await updateSessionMetadata(workspace.rootPath, sessionId, {
      name: sessionKey,
      channel: managed.channel,
    })
  }

  return await this.sendMessageHeadless(sessionId, content)
}
```

**Implementation notes:**
- Session lookup is two-phase: in-memory first (fast path), then persisted sessions (cold start after app restart).
- New sessions use `safe` permission mode (read-only) and workspace default working directory. This matches the P7 mitigation from research.
- `managed.channel` may not exist on the `ManagedSession` interface yet. If it does not exist, add `channel?: { adapter: string; slug: string; displayName?: string }` to the `ManagedSession` interface. Check the existing interface definition. The Session type in shared/types.ts already has this field, but ManagedSession is a separate internal interface.
- `updateSessionMetadata` is already imported and supports arbitrary metadata fields.
- For the stored session loading, the messages mapping may need adjustment to match the full `Message` type. If there are required fields beyond `id, role, content, timestamp`, add them. Check the existing session loading code elsewhere in SessionManager for the correct pattern (look at `loadSession` or `getSessionMessages`).

Do NOT modify the existing `createSession`, `sendMessage`, or `getOrCreateAgent` methods. This is purely additive.
  </action>
  <verify>
Run `bun run typecheck:all`. Verify processDaemonMessage compiles, particularly the ManagedSession type and the updateSessionMetadata call.
  </verify>
  <done>
- processDaemonMessage() added to SessionManager
- Finds/creates sessions by sessionKey match
- New sessions have safe mode, channel attribution, and sessionKey as name
- Session metadata persisted on creation
- ManagedSession interface has channel field (if it didn't already)
- typecheck passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle process_message in daemon event callback</name>
  <files>
    apps/electron/src/main/index.ts
  </files>
  <action>
In `apps/electron/src/main/index.ts`, modify the DaemonManager `onEvent` callback (around line 329-338) to handle `process_message` events.

The current callback is:
```typescript
(event) => {
  mainLog.info('[daemon] event:', event.type)
  for (const win of BrowserWindow.getAllWindows()) {
    if (!win.isDestroyed()) win.webContents.send(IPC_CHANNELS.DAEMON_EVENT, event)
  }
  if (event.type === 'status_changed' && event.status === 'running' && daemonManager) {
    deliverChannelConfigs(daemonManager, getCredentialManager).catch(...)
  }
},
```

Add a new branch for `process_message`:
```typescript
if (event.type === 'process_message' && sessionManager && daemonManager) {
  // Process daemon message asynchronously (don't block event handler)
  sessionManager.processDaemonMessage(
    event.workspaceId,
    event.sessionKey,
    event.content,
    { adapter: event.channelId, slug: event.channelId },
  ).then((response) => {
    daemonManager!.sendCommand({
      type: 'message_processed',
      messageId: event.messageId,
      response,
      success: true,
    })
  }).catch((err) => {
    mainLog.error('[daemon] Message processing error:', err)
    daemonManager!.sendCommand({
      type: 'message_processed',
      messageId: event.messageId,
      response: '',
      success: false,
      error: err instanceof Error ? err.message : String(err),
    })
  })
}
```

Place this BEFORE the existing `status_changed` check. The `process_message` event should NOT be forwarded to renderer windows (it's an internal daemon-to-main handshake), so add an early return or skip the `BrowserWindow.getAllWindows()` broadcast for this event type.

Pattern:
```typescript
(event) => {
  mainLog.info('[daemon] event:', event.type)

  // Handle process_message internally (daemon -> main -> daemon round-trip)
  if (event.type === 'process_message' && sessionManager && daemonManager) {
    sessionManager.processDaemonMessage(
      event.workspaceId,
      event.sessionKey,
      event.content,
      { adapter: event.channelId, slug: event.channelId },
    ).then((response) => {
      daemonManager!.sendCommand({
        type: 'message_processed',
        messageId: event.messageId,
        response,
        success: true,
      })
    }).catch((err) => {
      mainLog.error('[daemon] Message processing error:', err)
      daemonManager!.sendCommand({
        type: 'message_processed',
        messageId: event.messageId,
        response: '',
        success: false,
        error: err instanceof Error ? err.message : String(err),
      })
    })
    return  // Don't broadcast internal events to renderer
  }

  // Broadcast other events to renderer windows
  for (const win of BrowserWindow.getAllWindows()) {
    if (!win.isDestroyed()) win.webContents.send(IPC_CHANNELS.DAEMON_EVENT, event)
  }
  if (event.type === 'status_changed' && event.status === 'running' && daemonManager) {
    deliverChannelConfigs(daemonManager, getCredentialManager).catch((err) => {
      mainLog.error('[daemon] Failed to deliver channel configs:', err)
    })
  }
},
```

The `daemonManager!` non-null assertion is safe here because the `if` guard checks `daemonManager` is truthy. TypeScript may not narrow the closure-captured variable inside `.then()`, so the `!` assertion is needed.

Do NOT move or restructure any other code in index.ts. This is a targeted addition to the existing event callback.
  </action>
  <verify>
Run `bun run typecheck:all`. Verify the DaemonEvent discriminated union narrows correctly for `event.type === 'process_message'` and that `event.messageId`, `event.sessionKey`, etc. are accessible.
  </verify>
  <done>
- process_message events handled in daemon onEvent callback
- processDaemonMessage called with workspaceId, sessionKey, content, channelInfo
- Success: message_processed command sent with response text
- Failure: message_processed command sent with error
- process_message events NOT broadcast to renderer (internal only)
- typecheck passes
  </done>
</task>

</tasks>

<verification>
```bash
bun run typecheck:all
bun test
```

Full type check and test suite pass. The end-to-end flow is wired:
1. Daemon dequeues inbound message (Plan 01)
2. Daemon emits process_message to main process (Plan 01)
3. Main process creates/reuses session and runs agent headlessly (Plan 02)
4. Main process sends message_processed command back (Plan 02)
5. Daemon marks processed, enqueues outbound, delivers via adapter (Plan 01)
</verification>

<success_criteria>
- SessionManager.processDaemonMessage() creates or reuses sessions by sessionKey
- SessionManager.sendMessageHeadless() runs CraftAgent without renderer IPC
- index.ts daemon event handler processes process_message and returns message_processed
- Errors are caught and forwarded as failed message_processed commands
- process_message events are not broadcast to renderer windows
- All type checks pass, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/pending/17-end-to-end-message-processing/17-02-SUMMARY.md`
</output>

---
phase: 17-end-to-end-message-processing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/electron/src/main/index.ts
  - apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Channel badge (Hash icon) visible in chat list for Slack sessions"
    - "Channel toggle controls daemon lifecycle"
  artifacts:
    - path: apps/electron/src/main/index.ts
      what: "Resolve adapter type from channel config on disk instead of using channelId (slug)"
    - path: apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx
      what: "Auto-start daemon when first channel enabled, auto-stop when last channel disabled"
  key_links: []
---

<objective>
Fix channel badge adapter type resolution and add daemon lifecycle coordination to channel toggle.

Purpose: Gap 3 — channel sessions show a generic Radio icon instead of the Hash (Slack) icon because the adapter field is set to the slug (e.g., "slack-kata-agent") instead of the adapter type ("slack"). Gap 1 — enabling/disabling channels requires manual daemon start/stop.

Output: Two independent fixes in separate files.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/phases/completed/17-end-to-end-message-processing/17-UAT.md
@apps/electron/src/main/index.ts (lines 335-360)
@apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx
@apps/electron/src/main/ipc.ts (lines 2570-2600, channel config reading pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Resolve adapter type from channel config in process_message handler</name>
  <files>apps/electron/src/main/index.ts</files>
  <action>
In the `process_message` event handler (around line 336), the code passes `{ adapter: event.channelId, slug: event.channelId }` to `processDaemonMessage`. The `event.channelId` is the channel slug (e.g., "slack-kata-agent"), not the adapter type (e.g., "slack").

Fix: Look up the channel config from disk to get the correct adapter type.

1. Add imports at the top of index.ts:
   ```typescript
   import { existsSync, readFileSync } from 'fs'
   ```
   (These may already be imported — check first and only add if missing.)

2. Add a helper function before the daemon event handler (or inline in the handler):
   ```typescript
   function resolveAdapterType(workspaceId: string, channelSlug: string): string {
     try {
       const workspace = getWorkspaceByNameOrId(workspaceId)
       if (!workspace) return channelSlug
       const rootPath = workspace.rootPath.replace(/^~/, homedir())
       const configPath = join(rootPath, 'channels', channelSlug, 'config.json')
       if (!existsSync(configPath)) return channelSlug
       const config = JSON.parse(readFileSync(configPath, 'utf-8'))
       return config.adapter || channelSlug
     } catch {
       return channelSlug
     }
   }
   ```
   Check that `getWorkspaceByNameOrId`, `homedir`, `join`, `existsSync`, `readFileSync` are already imported. Add any missing imports.

3. Update the `processDaemonMessage` call at line 341 from:
   ```typescript
   { adapter: event.channelId, slug: event.channelId },
   ```
   to:
   ```typescript
   { adapter: resolveAdapterType(event.workspaceId, event.channelId), slug: event.channelId },
   ```

This ensures `channel.adapter` is set to "slack" or "whatsapp" (matching the `CHANNEL_ICONS` lookup in `SessionList.tsx`), while `channel.slug` remains the full slug identifier.
  </action>
  <verify>
Run `bun run typecheck:all` to confirm no type errors.
Verify the `ChannelIcon` component in `SessionList.tsx` uses `CHANNEL_ICONS[adapter]` where keys are "slack" and "whatsapp" — confirming the resolved value will match.
  </verify>
  <done>
The `processDaemonMessage` call passes the adapter type (e.g., "slack") read from the channel's config.json on disk, not the channel slug. The channel badge icon will resolve correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auto-start/stop daemon on channel enable/disable toggle</name>
  <files>apps/electron/src/renderer/pages/settings/ChannelSettingsPage.tsx</files>
  <action>
The channel toggle in `handleToggleChannel` (line 115) only updates `config.enabled` via IPC. It does not start/stop the daemon. Users must manually click Start/Stop.

Fix: After toggling a channel, check if the daemon should auto-start or auto-stop.

1. Update `handleToggleChannel` (lines 115-130). After the `updateChannel` call succeeds and `setChannels` updates local state, add daemon lifecycle logic:

   ```typescript
   const handleToggleChannel = useCallback(
     async (channel: ChannelConfig, enabled: boolean) => {
       if (!activeWorkspaceId) return;
       const updated = { ...channel, enabled };
       try {
         await window.electronAPI.updateChannel(activeWorkspaceId, updated);
         setChannels((prev) => {
           const next = prev.map((c) => (c.slug === channel.slug ? updated : c));
           // Auto-start daemon when first channel enabled
           if (enabled && daemonState === "stopped") {
             const anyEnabled = next.some((c) => c.enabled);
             if (anyEnabled) {
               window.electronAPI.startDaemon().catch((err) =>
                 console.error("[ChannelSettings] Auto-start daemon failed:", err),
               );
             }
           }
           // Auto-stop daemon when last channel disabled
           if (!enabled && daemonState === "running") {
             const anyEnabled = next.some((c) => c.enabled);
             if (!anyEnabled) {
               window.electronAPI.stopDaemon().catch((err) =>
                 console.error("[ChannelSettings] Auto-stop daemon failed:", err),
               );
             }
           }
           return next;
         });
       } catch (err) {
         console.error("[ChannelSettings] Failed to update channel:", err);
         toast.error("Failed to update channel");
       }
     },
     [activeWorkspaceId, daemonState],
   );
   ```

   Key changes from the original:
   - The `setChannels` call now uses a callback form that returns `next` (the updated channels array).
   - Inside the callback, after computing `next`, check if we should auto-start or auto-stop.
   - `daemonState` is added to the dependency array of `useCallback`.
   - `window.electronAPI.startDaemon()` / `stopDaemon()` are fire-and-forget with error logging.
  </action>
  <verify>
Run `bun run typecheck:all` to confirm no type errors.
Verify `daemonState` is already available in component scope via `useAtomValue(daemonStateAtom)` at line 82.
  </verify>
  <done>
When a user enables the first channel, the daemon auto-starts. When a user disables the last channel, the daemon auto-stops. Manual Start/Stop button remains functional.
  </done>
</task>

</tasks>

<verification>
- `bun run typecheck:all` passes
- `bun run lint:electron` passes
- In `index.ts`, the `resolveAdapterType` function reads `config.adapter` from the channel's `config.json` file
- In `ChannelSettingsPage.tsx`, toggling a channel triggers daemon start/stop based on whether any channels remain enabled
</verification>

<success_criteria>
- Channel sessions created by the daemon have `channel.adapter` set to "slack" or "whatsapp" (not the slug), matching `CHANNEL_ICONS` keys in SessionList.tsx
- Enabling the first channel auto-starts the daemon; disabling the last channel auto-stops the daemon
- No regressions in typecheck or lint
</success_criteria>

<output>
After completion, create `.planning/phases/completed/17-end-to-end-message-processing/17-03-SUMMARY.md`
</output>

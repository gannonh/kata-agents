---
phase: 14-ui-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/electron/src/shared/types.ts
  - apps/electron/src/preload/index.ts
  - apps/electron/src/main/index.ts
  - apps/electron/src/main/tray-manager.ts
  - apps/electron/src/main/ipc.ts
  - apps/electron/resources/trayIconTemplate.png
  - apps/electron/resources/trayIconTemplate@2x.png
  - apps/electron/src/renderer/atoms/daemon.ts
  - apps/electron/src/renderer/components/ui/daemon-status-indicator.tsx
autonomous: true

must_haves:
  truths:
    - "Renderer can call getDaemonStatus(), startDaemon(), stopDaemon() via window.electronAPI"
    - "Daemon state changes broadcast from main process to all renderer windows"
    - "DaemonStatusIndicator displays colored dot with tooltip for all 6 daemon states"
    - "System tray icon appears with context menu (Show Window, Start/Stop Daemon, Quit)"
    - "App stays alive when all windows are closed if daemon is running"
    - "Session type has optional channel field for daemon-created sessions"
  artifacts:
    - path: "apps/electron/src/main/tray-manager.ts"
      provides: "TrayManager class encapsulating Electron Tray lifecycle"
      exports: ["TrayManager"]
    - path: "apps/electron/src/renderer/atoms/daemon.ts"
      provides: "Jotai atoms for daemon state in renderer"
      exports: ["daemonStateAtom"]
    - path: "apps/electron/src/renderer/components/ui/daemon-status-indicator.tsx"
      provides: "DaemonStatusIndicator component with colored dot and tooltip"
      exports: ["DaemonStatusIndicator"]
  key_links:
    - from: "apps/electron/src/main/index.ts"
      to: "apps/electron/src/main/tray-manager.ts"
      via: "TrayManager instantiation and daemon state forwarding"
      pattern: "TrayManager"
    - from: "apps/electron/src/main/index.ts"
      to: "apps/electron/src/shared/types.ts"
      via: "DAEMON_STATE_CHANGED and DAEMON_EVENT IPC channels"
      pattern: "DAEMON_STATE_CHANGED"
    - from: "apps/electron/src/renderer/components/ui/daemon-status-indicator.tsx"
      to: "apps/electron/src/renderer/atoms/daemon.ts"
      via: "useAtom(daemonStateAtom)"
      pattern: "daemonStateAtom"
---

<objective>
Wire daemon subsystem to the Electron renderer and system tray. Add IPC plumbing for daemon state/events, create the TrayManager, build the DaemonStatusIndicator component, and extend the Session type with an optional channel field.

Purpose: Makes the always-on daemon visible and controllable from the UI (DAEMON-03, DAEMON-07) and prepares the Session type for channel sessions (CHAN-06 foundation).

Output: TrayManager class, daemon IPC bridge, daemon state atom, DaemonStatusIndicator component, Session.channel type extension.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/14-ui-integration/14-RESEARCH.md
@apps/electron/src/shared/types.ts
@apps/electron/src/preload/index.ts
@apps/electron/src/main/index.ts
@apps/electron/src/main/daemon-manager.ts
@apps/electron/src/main/ipc.ts
@apps/electron/src/renderer/components/ui/source-status-indicator.tsx
@apps/electron/src/renderer/atoms/sources.ts
@packages/core/src/types/daemon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IPC channels, preload bridge, Session.channel type, tray icon assets, and daemon event forwarding</name>
  <files>
    apps/electron/src/shared/types.ts
    apps/electron/src/preload/index.ts
    apps/electron/src/main/index.ts
    apps/electron/src/main/ipc.ts
    apps/electron/resources/trayIconTemplate.png
    apps/electron/resources/trayIconTemplate@2x.png
  </files>
  <action>
**1. Extend IPC_CHANNELS in `apps/electron/src/shared/types.ts`:**

Add these entries to the `IPC_CHANNELS` constant, after the existing `DAEMON_STATUS` entry:

```typescript
// Daemon events (main -> renderer broadcast)
DAEMON_STATE_CHANGED: 'daemon:stateChanged',
DAEMON_EVENT: 'daemon:event',
```

**2. Import and re-export DaemonManagerState in types.ts:**

At the top of the file, add:
```typescript
import type { DaemonManagerState } from '../main/daemon-manager';
export type { DaemonManagerState };
```

Since the main process type is imported, and preload runs in Node context, this is safe. However, if the build complains about importing from `main/`, instead define the type inline:
```typescript
export type DaemonManagerState = 'stopped' | 'starting' | 'running' | 'stopping' | 'error' | 'paused';
```

Use the inline approach (more portable, no cross-boundary import).

**3. Extend the `Session` interface in types.ts:**

Add after the existing `messageCount?: number` field:

```typescript
/** Channel origin for daemon-created sessions (absent for direct/interactive sessions) */
channel?: {
  /** Adapter type: 'slack', 'whatsapp', etc. */
  adapter: string
  /** Channel config slug */
  slug: string
  /** Display name for the channel source (e.g., '#general', 'Support Group') */
  displayName?: string
}
```

**4. Extend the `ElectronAPI` interface in types.ts:**

Add after `getGitStatus`:
```typescript
// Daemon management
getDaemonStatus(): Promise<DaemonManagerState>
startDaemon(): Promise<DaemonManagerState>
stopDaemon(): Promise<DaemonManagerState>
onDaemonStateChanged(callback: (state: DaemonManagerState) => void): () => void
onDaemonEvent(callback: (event: import('@craft-agent/core/types').DaemonEvent) => void): () => void
```

**5. Extend preload bridge in `apps/electron/src/preload/index.ts`:**

Add after the `onGitStatusChanged` block (before the Git Bash section):

```typescript
// Daemon management
getDaemonStatus: () => ipcRenderer.invoke(IPC_CHANNELS.DAEMON_STATUS),
startDaemon: () => ipcRenderer.invoke(IPC_CHANNELS.DAEMON_START),
stopDaemon: () => ipcRenderer.invoke(IPC_CHANNELS.DAEMON_STOP),
onDaemonStateChanged: (callback: (state: string) => void) => {
  const handler = (_event: Electron.IpcRendererEvent, state: string) => {
    callback(state)
  }
  ipcRenderer.on(IPC_CHANNELS.DAEMON_STATE_CHANGED, handler)
  return () => ipcRenderer.removeListener(IPC_CHANNELS.DAEMON_STATE_CHANGED, handler)
},
onDaemonEvent: (callback: (event: any) => void) => {
  const handler = (_event: Electron.IpcRendererEvent, daemonEvent: any) => {
    callback(daemonEvent)
  }
  ipcRenderer.on(IPC_CHANNELS.DAEMON_EVENT, handler)
  return () => ipcRenderer.removeListener(IPC_CHANNELS.DAEMON_EVENT, handler)
},
```

**6. Update DaemonManager callbacks in `apps/electron/src/main/index.ts`:**

Find the DaemonManager constructor call (around line 320-326). Replace the event and state callbacks:

From:
```typescript
(event) => mainLog.info('[daemon] event:', event.type),
(state) => mainLog.info('[daemon] state:', state),
```

To:
```typescript
(event) => {
  mainLog.info('[daemon] event:', event.type)
  for (const win of BrowserWindow.getAllWindows()) {
    win.webContents.send(IPC_CHANNELS.DAEMON_EVENT, event)
  }
},
(state) => {
  mainLog.info('[daemon] state:', state)
  for (const win of BrowserWindow.getAllWindows()) {
    win.webContents.send(IPC_CHANNELS.DAEMON_STATE_CHANGED, state)
  }
  trayManager?.updateState(state)
},
```

Add the `IPC_CHANNELS` import if not already present:
```typescript
import { IPC_CHANNELS } from '../shared/types'
```

Also add a module-level variable for the tray manager (near `let daemonManager`):
```typescript
let trayManager: TrayManager | null = null
```

And import TrayManager:
```typescript
import { TrayManager } from './tray-manager'
```

**7. Modify `window-all-closed` handler in index.ts:**

Replace the existing handler:
```typescript
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})
```

With:
```typescript
app.on('window-all-closed', () => {
  const daemonRunning = daemonManager?.getState() === 'running'
  if (process.platform === 'darwin' || daemonRunning) {
    return
  }
  app.quit()
})
```

**8. Create tray icon assets:**

Create 16x16 and 32x32 PNG tray icons. Use a simple monochrome version of the app icon.

Generate using the existing `icon.png` as source. Create `apps/electron/resources/trayIconTemplate.png` (16x16) and `apps/electron/resources/trayIconTemplate@2x.png` (32x32).

Use `sips` (macOS built-in) to resize the existing icon:
```bash
sips -z 16 16 apps/electron/resources/icon.png --out apps/electron/resources/trayIconTemplate.png
sips -z 32 32 apps/electron/resources/icon.png --out apps/electron/resources/trayIconTemplate@2x.png
```

If the full-color icon looks poor at small sizes, create a simple filled circle as placeholder. The key requirement is that the files exist and load.
  </action>
  <verify>
`bun run typecheck:all` passes with no type errors related to the new IPC channels, ElectronAPI methods, or Session.channel field. The tray icon PNG files exist in `apps/electron/resources/`.
  </verify>
  <done>
IPC channels DAEMON_STATE_CHANGED and DAEMON_EVENT exist. Preload exposes getDaemonStatus, startDaemon, stopDaemon, onDaemonStateChanged, onDaemonEvent. Session type has optional channel field. DaemonManager forwards events and state to all renderer windows. window-all-closed keeps app alive when daemon is running. Tray icon assets exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TrayManager, daemon state atom, and DaemonStatusIndicator</name>
  <files>
    apps/electron/src/main/tray-manager.ts
    apps/electron/src/renderer/atoms/daemon.ts
    apps/electron/src/renderer/components/ui/daemon-status-indicator.tsx
    apps/electron/src/main/index.ts
  </files>
  <action>
**1. Create `apps/electron/src/main/tray-manager.ts`:**

```typescript
import { Tray, Menu, nativeImage, BrowserWindow, app } from 'electron'
import type { DaemonManagerState } from './daemon-manager'
import { join } from 'path'

export class TrayManager {
  private tray: Tray | null = null

  constructor(
    private readonly resourcesDir: string,
    private readonly onShowWindow: () => void,
    private readonly onStartDaemon: () => Promise<void>,
    private readonly onStopDaemon: () => Promise<void>,
  ) {}

  create(): void {
    const iconPath = join(this.resourcesDir, 'trayIconTemplate.png')
    const icon = nativeImage.createFromPath(iconPath)
    const resized = icon.resize({ width: 16, height: 16 })
    if (process.platform === 'darwin') {
      resized.setTemplateImage(true)
    }
    this.tray = new Tray(resized)
    this.tray.setToolTip('Kata Agents')
    this.updateMenu('stopped')
  }

  updateState(state: DaemonManagerState): void {
    this.updateMenu(state)
    this.tray?.setToolTip(`Kata Agents â€” Daemon: ${state}`)
  }

  private updateMenu(state: DaemonManagerState): void {
    const isRunning = state === 'running'
    const contextMenu = Menu.buildFromTemplate([
      {
        label: 'Show Kata Agents',
        click: () => this.onShowWindow(),
      },
      { type: 'separator' },
      {
        label: isRunning ? 'Daemon Running' : `Daemon ${state.charAt(0).toUpperCase() + state.slice(1)}`,
        enabled: false,
      },
      {
        label: isRunning ? 'Stop Daemon' : 'Start Daemon',
        enabled: state === 'running' || state === 'stopped' || state === 'error' || state === 'paused',
        click: () => {
          if (isRunning) {
            this.onStopDaemon().catch(() => {})
          } else {
            this.onStartDaemon().catch(() => {})
          }
        },
      },
      { type: 'separator' },
      { role: 'quit' },
    ])
    this.tray?.setContextMenu(contextMenu)
  }

  destroy(): void {
    this.tray?.destroy()
    this.tray = null
  }
}
```

**2. Wire TrayManager in `apps/electron/src/main/index.ts`:**

After the DaemonManager is created and IPC handlers are registered, inside the `app.whenReady()` block (after `registerIpcHandlers`), add:

```typescript
// Initialize system tray
const resourcesDir = isPackagedApp()
  ? join(process.resourcesPath, 'resources')
  : join(__dirname, '../../resources')
trayManager = new TrayManager(
  resourcesDir,
  () => {
    const windows = windowManager?.getAllWindows()
    if (windows?.length) {
      const win = windows[0].window
      if (win.isMinimized()) win.restore()
      win.show()
      win.focus()
    } else {
      windowManager?.createWindow({ workspaceId: getWorkspaces()[0]?.id || '' })
    }
  },
  async () => { await daemonManager?.start() },
  async () => { await daemonManager?.stop() },
)
trayManager.create()
```

Determine the correct resourcesDir path by checking how existing resources (like icon.png) are resolved in the codebase. Search for `resources` path resolution patterns in the existing code. Use `isPackagedApp()` to determine the path:
- Packaged: `join(process.resourcesPath, 'resources')`
- Dev: `join(__dirname, '../../resources')` (or however the existing code resolves it)

Verify the path by checking where the existing icon.png is referenced.

**3. Create `apps/electron/src/renderer/atoms/daemon.ts`:**

```typescript
import { atom } from 'jotai'
import type { DaemonManagerState } from '../../shared/types'

/**
 * Current daemon process state, updated via IPC from main process.
 * Used by DaemonStatusIndicator and tray state.
 */
export const daemonStateAtom = atom<DaemonManagerState>('stopped')
```

**4. Create `apps/electron/src/renderer/components/ui/daemon-status-indicator.tsx`:**

Follow the SourceStatusIndicator pattern exactly:

```tsx
/**
 * DaemonStatusIndicator - Shows daemon process status
 *
 * A small colored dot that indicates the daemon's state:
 * - Green (pulse): Running
 * - Blue: Starting/Stopping
 * - Red: Error
 * - Yellow: Paused (after repeated failures)
 * - Gray: Stopped
 *
 * Hovering shows a tooltip with the status description.
 */

import * as React from 'react'
import { cn } from '@/lib/utils'
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from '@craft-agent/ui'
import type { DaemonManagerState } from '../../../shared/types'

export interface DaemonStatusIndicatorProps {
  state: DaemonManagerState
  size?: 'xs' | 'sm' | 'md'
  className?: string
}

const DAEMON_STATUS_CONFIG: Record<DaemonManagerState, {
  color: string
  pulseColor: string
  label: string
  description: string
}> = {
  running: {
    color: 'bg-success',
    pulseColor: 'bg-success/80',
    label: 'Running',
    description: 'Daemon is running and processing channel messages',
  },
  stopped: {
    color: 'bg-foreground/40',
    pulseColor: 'bg-foreground/30',
    label: 'Stopped',
    description: 'Daemon is not running',
  },
  starting: {
    color: 'bg-info',
    pulseColor: 'bg-info/80',
    label: 'Starting',
    description: 'Daemon is starting up',
  },
  stopping: {
    color: 'bg-info',
    pulseColor: 'bg-info/80',
    label: 'Stopping',
    description: 'Daemon is shutting down',
  },
  error: {
    color: 'bg-destructive',
    pulseColor: 'bg-destructive/80',
    label: 'Error',
    description: 'Daemon encountered an error',
  },
  paused: {
    color: 'bg-warning',
    pulseColor: 'bg-warning/80',
    label: 'Paused',
    description: 'Daemon paused after repeated failures',
  },
}

const SIZE_CONFIG: Record<'xs' | 'sm' | 'md', string> = {
  xs: 'h-1.5 w-1.5',
  sm: 'h-2 w-2',
  md: 'h-2.5 w-2.5',
}

export function DaemonStatusIndicator({
  state,
  size = 'sm',
  className,
}: DaemonStatusIndicatorProps) {
  const config = DAEMON_STATUS_CONFIG[state]
  const sizeClass = SIZE_CONFIG[size]

  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <span
          className={cn(
            'relative inline-flex shrink-0',
            className
          )}
        >
          {state === 'running' && (
            <span
              className={cn(
                'absolute inline-flex rounded-full opacity-75 animate-ping',
                config.pulseColor,
                sizeClass
              )}
              style={{ animationDuration: '2s' }}
            />
          )}
          <span
            className={cn(
              'relative inline-flex rounded-full',
              config.color,
              sizeClass
            )}
          />
        </span>
      </TooltipTrigger>
      <TooltipContent side="top" className="max-w-xs">
        <div className="flex flex-col gap-0.5">
          <span className="font-medium">{config.label}</span>
          <span className="text-foreground/60">{config.description}</span>
        </div>
      </TooltipContent>
    </Tooltip>
  )
}
```

**5. Add `DaemonManagerState` to the `SessionMeta` interface:**

In `apps/electron/src/renderer/atoms/sessions.ts`, add to the `SessionMeta` interface:

```typescript
/** Channel info for daemon-created sessions */
channel?: {
  adapter: string
  slug: string
  displayName?: string
}
```

This mirrors the `Session.channel` field added to the shared types.
  </action>
  <verify>
`bun run typecheck:all` passes. Verify the TrayManager class compiles and all exports resolve. Verify the DaemonStatusIndicator component renders without errors by checking that the import paths and types are valid.
  </verify>
  <done>
TrayManager creates system tray icon with context menu. DaemonStatusIndicator renders colored dot for all 6 states. daemonStateAtom exists for renderer state tracking. SessionMeta has channel field. Tray is wired into main process lifecycle with show/start/stop/quit actions.
  </done>
</task>

</tasks>

<verification>
- `bun run typecheck:all` passes
- `bun run lint:electron` passes (or has only pre-existing warnings)
- IPC channels DAEMON_STATE_CHANGED and DAEMON_EVENT defined in IPC_CHANNELS
- ElectronAPI has getDaemonStatus, startDaemon, stopDaemon, onDaemonStateChanged, onDaemonEvent
- Preload bridge exposes all 5 daemon management methods
- Session type has optional `channel` field
- SessionMeta has optional `channel` field
- DaemonManager callbacks forward events and state to renderer windows
- window-all-closed keeps app alive when daemon is running
- TrayManager class exists with create/updateState/destroy lifecycle
- TrayManager is instantiated in main/index.ts after app.whenReady
- daemonStateAtom exists in renderer/atoms/daemon.ts
- DaemonStatusIndicator component exists with all 6 states styled
</verification>

<success_criteria>
- Daemon state changes propagate from DaemonManager through IPC to renderer windows
- System tray icon appears with functional context menu (Show Window, Start/Stop Daemon, Quit)
- App remains alive with tray when all windows close and daemon is running
- DaemonStatusIndicator displays correct color and tooltip for each of the 6 states
- Session.channel type extension allows daemon-created sessions to carry origin metadata
</success_criteria>

<output>
After completion, create `.planning/phases/14-ui-integration/14-01-SUMMARY.md`
</output>

---
phase: 13-plugin-lifecycle-and-task-scheduler
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/daemon/task-scheduler.ts
  - packages/shared/src/daemon/types.ts
  - packages/shared/src/daemon/message-queue.ts
  - packages/shared/src/daemon/index.ts
  - packages/shared/src/daemon/__tests__/task-scheduler.test.ts
autonomous: true

must_haves:
  truths:
    - "Scheduled tasks are persisted in SQLite and survive daemon restarts"
    - "Cron tasks fire at the correct times computed by croner"
    - "Interval tasks repeat at the configured interval"
    - "One-shot tasks fire once and are marked complete"
    - "Tasks missed during daemon downtime (nextRunAt < now) execute on startup catch-up"
    - "stop() cancels pending timers and awaits in-flight task callbacks"
  artifacts:
    - path: "packages/shared/src/daemon/task-scheduler.ts"
      provides: "TaskScheduler class with SQLite persistence, croner scheduling, lifecycle management"
      exports: ["TaskScheduler"]
    - path: "packages/shared/src/daemon/types.ts"
      provides: "ScheduledTask, TaskType, TaskAction type definitions"
      contains: "ScheduledTask"
    - path: "packages/shared/src/daemon/__tests__/task-scheduler.test.ts"
      provides: "Unit tests for TaskScheduler CRUD, scheduling, catch-up, and shutdown"
  key_links:
    - from: "packages/shared/src/daemon/task-scheduler.ts"
      to: "bun:sqlite"
      via: "Database instance shared with MessageQueue"
      pattern: "Database"
    - from: "packages/shared/src/daemon/task-scheduler.ts"
      to: "croner"
      via: "Cron class for next-run calculation"
      pattern: "Cron"
---

<objective>
Build the TaskScheduler class that persists cron, interval, and one-shot tasks in SQLite and executes them using croner-based timers.

Purpose: Enable daemon-managed recurring and scheduled operations (channel health checks, periodic digests, deferred actions) that survive restarts.

Output: TaskScheduler class, ScheduledTask types, SQLite schema extension, and unit tests.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/shared/src/daemon/message-queue.ts
@packages/shared/src/daemon/types.ts
@packages/shared/src/daemon/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ScheduledTask types and install croner</name>
  <files>
    packages/shared/src/daemon/types.ts
    package.json (root)
  </files>
  <action>
Install croner:
```bash
bun add croner
```

Add the following types to `packages/shared/src/daemon/types.ts` (append after existing types, do not modify existing):

```typescript
/**
 * Type of scheduled task.
 * - `cron`: Fires on a cron schedule (e.g., "0 9 * * 1-5")
 * - `interval`: Fires every N milliseconds
 * - `one-shot`: Fires once at a specific datetime, then marked complete
 */
export type TaskType = 'cron' | 'interval' | 'one-shot';

/**
 * Actions a scheduled task can trigger.
 * Discriminated union on `type`.
 */
export type TaskAction =
  | { type: 'send_message'; workspaceId: string; sessionKey: string; message: string }
  | { type: 'plugin_action'; pluginId: string; action: string; payload?: unknown };

/**
 * A scheduled task persisted in SQLite.
 */
export interface ScheduledTask {
  /** Auto-incremented row ID */
  id: number;
  /** Workspace this task belongs to */
  workspaceId: string;
  /** Task type: cron, interval, or one-shot */
  type: TaskType;
  /** Schedule expression: cron string, interval ms as string, or ISO datetime for one-shot */
  schedule: string;
  /** Action to perform when the task fires */
  action: TaskAction;
  /** Whether the task is active */
  enabled: boolean;
  /** ISO timestamp of last execution, or null */
  lastRunAt: string | null;
  /** ISO timestamp of next scheduled execution */
  nextRunAt: string;
  /** ISO timestamp when the task was created */
  createdAt: string;
}
```

Update the barrel exports in `packages/shared/src/daemon/types.ts` re-exports section if needed: the new types are defined directly in the file, so they'll be available.
  </action>
  <verify>
`cd packages/shared && bun run tsc --noEmit` passes.
`bun pm ls | grep croner` shows croner installed.
  </verify>
  <done>
ScheduledTask, TaskType, and TaskAction types exist. croner is installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TaskScheduler class with SQLite persistence and croner scheduling</name>
  <files>
    packages/shared/src/daemon/task-scheduler.ts
    packages/shared/src/daemon/message-queue.ts
    packages/shared/src/daemon/index.ts
    packages/shared/src/daemon/__tests__/task-scheduler.test.ts
  </files>
  <action>
Create `packages/shared/src/daemon/task-scheduler.ts`:

The TaskScheduler takes a `Database` instance (shared with MessageQueue) and an `onTask` callback. It manages scheduled_tasks table creation, CRUD, and timer scheduling.

**Constructor:**
- Accepts `db: Database` and `onTask: (task: ScheduledTask) => Promise<void>` and optional `log: (msg: string) => void`
- Creates the `scheduled_tasks` table if not exists:
  ```sql
  CREATE TABLE IF NOT EXISTS scheduled_tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    workspace_id TEXT NOT NULL,
    type TEXT NOT NULL CHECK(type IN ('cron', 'interval', 'one-shot')),
    schedule TEXT NOT NULL,
    action TEXT NOT NULL,
    enabled INTEGER NOT NULL DEFAULT 1,
    last_run_at TEXT,
    next_run_at TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
  )
  ```
- Create index: `CREATE INDEX IF NOT EXISTS idx_scheduled_tasks_enabled ON scheduled_tasks (enabled, next_run_at) WHERE enabled = 1`
- Prepare statements for add, update, delete, list, and getById

**Methods:**

`addTask(input: { workspaceId, type, schedule, action, enabled? }): ScheduledTask` - Compute nextRunAt using croner's `Cron` class:
  - For `cron`: `new Cron(schedule).nextRun()?.toISOString()`
  - For `interval`: `new Date(Date.now() + parseInt(schedule)).toISOString()`
  - For `one-shot`: the schedule string IS the ISO datetime, use directly
  - Insert row, return the full task
  - Throws if cron expression is invalid

`removeTask(id: number): void` - Delete from DB, cancel active timer if running

`listTasks(workspaceId?: string): ScheduledTask[]` - Query all tasks, optionally filtered by workspace

`getTask(id: number): ScheduledTask | null` - Fetch single task by id

`start(): void` - Load all enabled tasks from DB. For each:
  - If `nextRunAt < now` (missed during downtime), fire catch-up immediately, then schedule next
  - Otherwise, schedule timer for `nextRunAt - now` ms
  - Store timer handles in `Map<number, ReturnType<typeof setTimeout>>`

`stop(): Promise<void>` - Clear all timers (clearTimeout). Await any in-flight task executions using a Set<Promise<void>> tracking active callbacks.

**Internal `scheduleNext(task)` method:**
  - Compute delay = nextRunAt - now
  - setTimeout at that delay, when fired:
    1. Add to inFlight set
    2. Call `onTask(task)`, await it
    3. Update `last_run_at = now` in DB
    4. Compute new `next_run_at`:
       - `cron`: `new Cron(schedule).nextRun()?.toISOString()`
       - `interval`: `new Date(Date.now() + parseInt(schedule)).toISOString()`
       - `one-shot`: mark `enabled = false`, no reschedule
    5. Update DB row with new `next_run_at` and `last_run_at`
    6. If not one-shot, call `scheduleNext(updatedTask)` recursively
    7. Remove from inFlight set

**SQLite row mapping:** Same pattern as MessageQueue: snake_case columns mapped to camelCase ScheduledTask at the query boundary.

Modify `packages/shared/src/daemon/message-queue.ts`:
- Export the `Database` instance via a new getter: `getDb(): Database` so TaskScheduler can share it. This avoids opening a second connection to daemon.db.

Update `packages/shared/src/daemon/index.ts`:
- Add export for `TaskScheduler`
- Add type exports for `ScheduledTask`, `TaskType`, `TaskAction`

Create `packages/shared/src/daemon/__tests__/task-scheduler.test.ts`:

Use `Database(':memory:')` for tests (import from `bun:sqlite`). Create test instances without needing MessageQueue.

Tests:
1. `addTask creates a cron task with computed nextRunAt` - Add a cron task, verify nextRunAt is in the future
2. `addTask creates an interval task` - Add interval task with schedule "5000" (5s), verify nextRunAt is ~5s from now
3. `addTask creates a one-shot task` - Add one-shot with schedule as ISO date in the future, verify nextRunAt matches
4. `addTask throws for invalid cron expression` - Verify error on bad expression
5. `removeTask deletes task from DB` - Add then remove, verify listTasks returns empty
6. `listTasks filters by workspaceId` - Add tasks for two workspaces, verify filtering
7. `start fires catch-up for missed tasks` - Insert a task with nextRunAt in the past, call start(), verify onTask callback fires within 100ms
8. `start schedules future tasks` - Insert a task with nextRunAt 200ms in the future, verify callback fires after ~200ms (use timer with tolerance)
9. `one-shot task is disabled after firing` - Add one-shot, start, wait for fire, verify task.enabled is false in DB
10. `stop cancels pending timers` - Schedule a task 5s out, call stop(), verify callback never fires (wait 100ms)
  </action>
  <verify>
`bun test packages/shared/src/daemon/__tests__/task-scheduler.test.ts` passes all tests.
`cd packages/shared && bun run tsc --noEmit` passes.
  </verify>
  <done>
TaskScheduler persists tasks in SQLite, schedules them with croner, handles catch-up on restart, and cleans up on stop. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `cd packages/shared && bun run tsc --noEmit` passes
- `bun test packages/shared/src/daemon/__tests__/task-scheduler.test.ts` passes all tests
- `croner` is in package.json dependencies
- `scheduled_tasks` table schema matches the design
</verification>

<success_criteria>
- TaskScheduler CRUD operations persist to SQLite
- Cron, interval, and one-shot types all compute correct nextRunAt
- Missed tasks (nextRunAt < now) catch up on start()
- One-shot tasks disable after firing
- stop() cancels pending timers and waits for in-flight callbacks
</success_criteria>

<output>
After completion, create `.planning/phases/13-plugin-lifecycle-and-task-scheduler/13-02-SUMMARY.md`
</output>

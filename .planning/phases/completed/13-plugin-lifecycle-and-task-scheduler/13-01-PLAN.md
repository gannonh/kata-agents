---
phase: 13-plugin-lifecycle-and-task-scheduler
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/plugins/registry-impl.ts
  - packages/shared/src/plugins/plugin-manager.ts
  - packages/shared/src/plugins/builtin/index.ts
  - packages/shared/src/plugins/builtin/slack-plugin.ts
  - packages/shared/src/plugins/builtin/whatsapp-plugin.ts
  - packages/shared/src/plugins/index.ts
  - packages/shared/src/plugins/__tests__/plugin-manager.test.ts
autonomous: true

must_haves:
  truths:
    - "PluginManager loads all builtin plugins and registers only those in the enabled set"
    - "ChannelRegistryImpl produces adapter instances via factory functions"
    - "Slack plugin registers a 'slack' adapter factory that creates SlackChannelAdapter"
    - "WhatsApp plugin registers a 'whatsapp' adapter factory that creates WhatsAppChannelAdapter"
    - "Disabled plugins are tracked but their registration methods are not called"
  artifacts:
    - path: "packages/shared/src/plugins/registry-impl.ts"
      provides: "Concrete ChannelRegistry, ToolRegistry, ServiceRegistry implementations"
      exports: ["ChannelRegistryImpl", "ToolRegistryImpl", "ServiceRegistryImpl"]
    - path: "packages/shared/src/plugins/plugin-manager.ts"
      provides: "PluginManager class that loads, registers, initializes, and shuts down plugins"
      exports: ["PluginManager"]
    - path: "packages/shared/src/plugins/builtin/slack-plugin.ts"
      provides: "Slack first-party plugin wrapping SlackChannelAdapter"
      exports: ["slackPlugin"]
    - path: "packages/shared/src/plugins/builtin/whatsapp-plugin.ts"
      provides: "WhatsApp first-party plugin wrapping WhatsAppChannelAdapter"
      exports: ["whatsappPlugin"]
    - path: "packages/shared/src/plugins/builtin/index.ts"
      provides: "Barrel export of all builtin plugins"
      exports: ["getBuiltinPlugins"]
  key_links:
    - from: "packages/shared/src/plugins/plugin-manager.ts"
      to: "packages/shared/src/plugins/builtin/index.ts"
      via: "getBuiltinPlugins() call in loadBuiltinPlugins()"
      pattern: "getBuiltinPlugins"
    - from: "packages/shared/src/plugins/builtin/slack-plugin.ts"
      to: "packages/shared/src/channels/adapters/slack-adapter.ts"
      via: "factory function in registerChannels"
      pattern: "SlackChannelAdapter"
    - from: "packages/shared/src/plugins/plugin-manager.ts"
      to: "packages/shared/src/plugins/registry-impl.ts"
      via: "ChannelRegistryImpl used internally"
      pattern: "ChannelRegistryImpl"
---

<objective>
Build the PluginManager class, concrete registry implementations, and first-party Slack/WhatsApp plugin wrappers.

Purpose: Provide the runtime machinery for loading builtin plugins, filtering by enabled set, and exposing an adapter factory that the ChannelRunner can use instead of the hardcoded `createAdapter` switch statement.

Output: PluginManager, registry implementations, two first-party plugins, and unit tests validating registration and filtering.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/shared/src/plugins/types.ts
@packages/shared/src/plugins/index.ts
@packages/shared/src/channels/types.ts
@packages/shared/src/channels/adapters/index.ts
@packages/shared/src/channels/adapters/slack-adapter.ts
@packages/shared/src/channels/adapters/whatsapp-adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create registry implementations and first-party plugin modules</name>
  <files>
    packages/shared/src/plugins/registry-impl.ts
    packages/shared/src/plugins/builtin/slack-plugin.ts
    packages/shared/src/plugins/builtin/whatsapp-plugin.ts
    packages/shared/src/plugins/builtin/index.ts
  </files>
  <action>
Create `packages/shared/src/plugins/registry-impl.ts` with three concrete registry classes:

1. `ChannelRegistryImpl` implements `ChannelRegistry`:
   - Internal `Map<string, () => ChannelAdapter>` storing adapter factories by id
   - `addAdapter(id, factory)` stores factory in the map
   - `createAdapter(type: string): ChannelAdapter | null` looks up factory by type, calls it, returns instance or null
   - `getRegisteredTypes(): string[]` returns array of registered type ids

2. `ToolRegistryImpl` implements `ToolRegistry`:
   - Internal array of tools
   - `addTool(tool)` pushes to array
   - `getTools(): unknown[]` returns copy of array

3. `ServiceRegistryImpl` implements `ServiceRegistry`:
   - Internal `Map<string, PluginService>` storing services by id
   - `addService(id, service)` stores in map
   - `getServices(): Map<string, PluginService>` returns the map

Create `packages/shared/src/plugins/builtin/slack-plugin.ts`:
```typescript
import type { KataPlugin, ChannelRegistry } from '../types.ts';
import { SlackChannelAdapter } from '../../channels/adapters/slack-adapter.ts';

export const slackPlugin: KataPlugin = {
  id: 'kata-slack',
  name: 'Slack',
  version: '0.7.0',
  registerChannels(registry: ChannelRegistry): void {
    registry.addAdapter('slack', () => new SlackChannelAdapter());
  },
};
```

Create `packages/shared/src/plugins/builtin/whatsapp-plugin.ts` following the same pattern with `WhatsAppChannelAdapter` and id `kata-whatsapp`.

Create `packages/shared/src/plugins/builtin/index.ts`:
```typescript
import type { KataPlugin } from '../types.ts';
import { slackPlugin } from './slack-plugin.ts';
import { whatsappPlugin } from './whatsapp-plugin.ts';

const BUILTIN_PLUGINS: readonly KataPlugin[] = [slackPlugin, whatsappPlugin];

export function getBuiltinPlugins(): readonly KataPlugin[] {
  return BUILTIN_PLUGINS;
}
```
  </action>
  <verify>
`cd packages/shared && bun run tsc --noEmit` passes with no type errors.
  </verify>
  <done>
Three registry implementations exist with typed APIs. Two first-party plugins wrap existing adapters. `getBuiltinPlugins()` returns both.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PluginManager class with filtering and lifecycle</name>
  <files>
    packages/shared/src/plugins/plugin-manager.ts
    packages/shared/src/plugins/index.ts
    packages/shared/src/plugins/__tests__/plugin-manager.test.ts
  </files>
  <action>
Create `packages/shared/src/plugins/plugin-manager.ts`:

```typescript
class PluginManager {
  private plugins: Map<string, KataPlugin> = new Map();
  private enabledIds: Set<string>;
  private channelRegistry: ChannelRegistryImpl;
  private toolRegistry: ToolRegistryImpl;
  private serviceRegistry: ServiceRegistryImpl;
  private initialized = false;

  constructor(enabledPluginIds: string[]) {
    this.enabledIds = new Set(enabledPluginIds);
    this.channelRegistry = new ChannelRegistryImpl();
    this.toolRegistry = new ToolRegistryImpl();
    this.serviceRegistry = new ServiceRegistryImpl();
  }

  loadBuiltinPlugins(): void {
    for (const plugin of getBuiltinPlugins()) {
      this.plugins.set(plugin.id, plugin);
      if (!this.enabledIds.has(plugin.id)) continue;
      plugin.registerChannels?.(this.channelRegistry);
      plugin.registerTools?.(this.toolRegistry);
      plugin.registerServices?.(this.serviceRegistry);
    }
  }

  getAdapterFactory(): (type: string) => ChannelAdapter | null {
    return (type) => this.channelRegistry.createAdapter(type);
  }

  getRegisteredPlugins(): Array<{ id: string; name: string; version: string; enabled: boolean }> {
    return Array.from(this.plugins.values()).map((p) => ({
      id: p.id,
      name: p.name,
      version: p.version,
      enabled: this.enabledIds.has(p.id),
    }));
  }

  async initializeAll(context: PluginContext): Promise<void> {
    if (this.initialized) return;
    for (const [id, plugin] of this.plugins) {
      if (!this.enabledIds.has(id)) continue;
      await plugin.initialize?.(context);
    }
    // Start registered services
    for (const [, service] of this.serviceRegistry.getServices()) {
      await service.start();
    }
    this.initialized = true;
  }

  async shutdownAll(): Promise<void> {
    // Stop services first
    for (const [, service] of this.serviceRegistry.getServices()) {
      await service.stop();
    }
    // Then shutdown plugins
    for (const [id, plugin] of this.plugins) {
      if (!this.enabledIds.has(id)) continue;
      await plugin.shutdown?.();
    }
    this.initialized = false;
  }
}
```

Update `packages/shared/src/plugins/index.ts` to add exports:
- Export `PluginManager` from `./plugin-manager.ts`
- Export `ChannelRegistryImpl`, `ToolRegistryImpl`, `ServiceRegistryImpl` from `./registry-impl.ts`
- Export `getBuiltinPlugins` from `./builtin/index.ts`
- Keep all existing type exports

Create `packages/shared/src/plugins/__tests__/plugin-manager.test.ts` with tests:
1. `loadBuiltinPlugins registers both builtin plugins` - verify `getRegisteredPlugins()` returns 2 entries when both enabled
2. `disabled plugins are tracked but not registered` - create PluginManager with empty enabled set, verify `getRegisteredPlugins()` shows both plugins with `enabled: false`, verify `getAdapterFactory()('slack')` returns null
3. `getAdapterFactory returns adapter for enabled plugin` - enable kata-slack, verify factory('slack') returns a SlackChannelAdapter instance
4. `getAdapterFactory returns null for unknown type` - verify factory('unknown') returns null
5. `initializeAll calls initialize on enabled plugins only` - create mock plugin with initialize spy, verify enabled plugin's initialize is called, disabled plugin's is not
6. `shutdownAll calls shutdown on enabled plugins` - similar to above with shutdown
  </action>
  <verify>
`bun test packages/shared/src/plugins/__tests__/plugin-manager.test.ts` passes all tests.
`cd packages/shared && bun run tsc --noEmit` passes.
  </verify>
  <done>
PluginManager loads builtin plugins, filters by enabled set, exposes adapter factory, and handles lifecycle. All tests pass.
  </done>
</task>

</tasks>

<verification>
- `cd packages/shared && bun run tsc --noEmit` passes
- `bun test packages/shared/src/plugins` passes all tests
- `getBuiltinPlugins()` returns both slack and whatsapp plugins
- `PluginManager` with `['kata-slack']` only registers slack adapter, not whatsapp
</verification>

<success_criteria>
- PluginManager loads builtin plugins and filters by an enabled set
- First-party plugins wrap existing adapters without modifying them
- Adapter factory from PluginManager produces correct adapter instances
- Unit tests validate registration, filtering, and lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/13-plugin-lifecycle-and-task-scheduler/13-01-SUMMARY.md`
</output>

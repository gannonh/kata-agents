---
phase: 19-tech-debt-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/types/session.ts
  - packages/core/src/types/index.ts
  - packages/core/src/types/daemon.ts
  - packages/shared/src/sessions/types.ts
  - packages/shared/src/daemon/entry.ts
  - packages/shared/src/daemon/channel-runner.ts
  - apps/electron/src/main/sessions.ts
autonomous: true
must_haves:
  truths:
    - ChannelOrigin type is defined in @craft-agent/core and exported from the barrel
    - Core Session interface includes an optional channel field typed as ChannelOrigin
    - SessionConfig, SessionHeader, and SessionMetadata in packages/shared reference ChannelOrigin from core
    - Electron Session type in apps/electron references ChannelOrigin from core
    - PluginManager.initializeAll() is called after loadBuiltinPlugins() in daemon entry
    - DaemonEvent union includes a channel_health variant
    - ChannelRunner polls adapter health every 30s and emits channel_health only on state change
    - Health polling timer is cleared in ChannelRunner.stopAll()
  artifacts:
    - packages/core/src/types/session.ts exports ChannelOrigin
    - packages/core/src/types/daemon.ts includes channel_health in DaemonEvent
    - packages/shared/src/daemon/channel-runner.ts contains health polling logic
  key_links:
    - packages/core/src/types/session.ts
    - packages/core/src/types/index.ts
    - packages/core/src/types/daemon.ts
    - packages/shared/src/sessions/types.ts
    - apps/electron/src/shared/types.ts
    - packages/shared/src/daemon/entry.ts
    - packages/shared/src/daemon/channel-runner.ts
---

<objective>
Close three tech debt items identified by the v0.7.0 milestone audit: extract the inline channel origin type to core, wire up plugin initialization in the daemon, and surface adapter health via daemon events.

Purpose: Eliminate type duplication across 4 files, activate the unused plugin lifecycle hook, and expose adapter health for future UI consumption.
Output: Updated core types, daemon entry, and channel runner with tests passing.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@packages/core/src/types/session.ts
@packages/core/src/types/index.ts
@packages/core/src/types/daemon.ts
@packages/shared/src/sessions/types.ts
@apps/electron/src/shared/types.ts
@packages/shared/src/daemon/entry.ts
@packages/shared/src/daemon/channel-runner.ts
@packages/shared/src/plugins/plugin-manager.ts
@packages/shared/src/plugins/types.ts
@packages/shared/src/channels/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract ChannelOrigin to core and unify Session types</name>
  <files>
    packages/core/src/types/session.ts
    packages/core/src/types/index.ts
    packages/shared/src/sessions/types.ts
    apps/electron/src/shared/types.ts
  </files>
  <action>
1. In `packages/core/src/types/session.ts`, add a new exported type above the `Session` interface:

```typescript
/**
 * Channel origin metadata for daemon-created sessions.
 * Describes which channel adapter and config produced the session.
 */
export interface ChannelOrigin {
  /** Adapter type: 'slack', 'whatsapp', etc. */
  adapter: string;
  /** Channel config slug */
  slug: string;
  /** Display name for the channel source (e.g., '#general', 'Support Group') */
  displayName?: string;
}
```

2. Add `channel?: ChannelOrigin` to the core `Session` interface (after the `lastReadMessageId` field).

3. In `packages/core/src/types/index.ts`, add `ChannelOrigin` to the session re-exports:
```typescript
export type {
  Session,
  StoredSession,
  SessionMetadata,
  SessionStatus,
  ChannelOrigin,
} from './session.ts';
```

4. In `packages/shared/src/sessions/types.ts`, replace the inline `channel?` type on `SessionConfig`, `SessionHeader`, and `SessionMetadata` with:
```typescript
import type { ChannelOrigin } from '@craft-agent/core/types';
// ...
channel?: ChannelOrigin;
```
Add the import at the top alongside the existing `@craft-agent/core/types` import line.

5. In `apps/electron/src/shared/types.ts`, replace the inline `channel?` type on the Electron `Session` interface with:
```typescript
import type { ChannelOrigin } from '@craft-agent/core/types';
// ...
channel?: ChannelOrigin;
```
Add `ChannelOrigin` to the existing core types import. Also add it to the re-export block so renderer code can access it.
  </action>
  <verify>
Run `bun run typecheck:all` from the monorepo root. All packages must pass with zero errors.
  </verify>
  <done>
- `ChannelOrigin` is defined once in `@craft-agent/core/types` and exported from the barrel
- Core `Session` includes `channel?: ChannelOrigin`
- `SessionConfig`, `SessionHeader`, and `SessionMetadata` in shared use `ChannelOrigin` from core (no inline type)
- Electron `Session` uses `ChannelOrigin` from core (no inline type)
- Type check passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Call PluginManager.initializeAll() in daemon entry</name>
  <files>packages/shared/src/daemon/entry.ts</files>
  <action>
In `packages/shared/src/daemon/entry.ts`, inside the `configure_channels` case handler, after the line:

```typescript
log(`PluginManager loaded with ${enabledPluginIds.size} enabled plugin(s)`);
```

Add the `initializeAll()` call:

```typescript
await state.pluginManager.initializeAll({
  workspaceRootPath: configDir,
  getCredential: async () => null,
  logger: {
    info: (msg: string) => log(`[plugin] ${msg}`),
    warn: (msg: string) => log(`[plugin:warn] ${msg}`),
    error: (msg: string) => log(`[plugin:error] ${msg}`),
    debug: (msg: string) => log(`[plugin:debug] ${msg}`),
  },
});
log('PluginManager initialized');
```

Import `PluginContext` is not needed since the object literal satisfies the interface structurally. The `configDir` variable is already in scope (defined at the top of `main()`).

Note: `getCredential` returns `null` because the daemon does not currently resolve per-source credentials for plugin initialization. Future work can wire this to the credential store.
  </action>
  <verify>
Run `bun run typecheck:all` from the monorepo root. Verify no type errors. Optionally run `bun test packages/shared` to confirm no regressions.
  </verify>
  <done>
- `initializeAll()` is called after `loadBuiltinPlugins()` in the `configure_channels` handler
- The `PluginContext` is constructed with `configDir` as `workspaceRootPath`, a null credential getter, and a logger that routes to the daemon's `log()` function
- Type check passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Add channel_health event and health polling in ChannelRunner</name>
  <files>
    packages/core/src/types/daemon.ts
    packages/shared/src/daemon/channel-runner.ts
  </files>
  <action>
1. In `packages/core/src/types/daemon.ts`, add a new variant to the `DaemonEvent` union (after the `process_message` variant):

```typescript
| {
    type: 'channel_health';
    /** Channel adapter slug */
    channelId: string;
    /** Whether the adapter is currently healthy */
    healthy: boolean;
    /** Error message if unhealthy, null if healthy */
    error: string | null;
  }
```

2. In `packages/shared/src/daemon/channel-runner.ts`:

a. Add a private field to track health state and the polling timer:
```typescript
private lastHealthState: Map<string, boolean> = new Map();
private healthTimer: ReturnType<typeof setInterval> | null = null;
```

b. Add a private method `pollHealth()`:
```typescript
private pollHealth(): void {
  for (const [slug, { adapter }] of this.adapters) {
    const healthy = adapter.isHealthy();
    const previous = this.lastHealthState.get(slug);

    // Only emit on state change (or first poll)
    if (previous === undefined || previous !== healthy) {
      this.lastHealthState.set(slug, healthy);
      this.emit({
        type: 'channel_health',
        channelId: slug,
        healthy,
        error: healthy ? null : adapter.getLastError(),
      });
    }
  }
}
```

c. At the end of `startAll()`, after the `this.log(...)` line, start the health polling timer:
```typescript
// Start health polling (30s interval, initial poll after first interval)
this.healthTimer = setInterval(() => this.pollHealth(), 30_000);
```

d. At the beginning of `stopAll()`, before the adapter stop loop, clear the timer and health state:
```typescript
if (this.healthTimer) {
  clearInterval(this.healthTimer);
  this.healthTimer = null;
}
this.lastHealthState.clear();
```
  </action>
  <verify>
Run `bun run typecheck:all` from the monorepo root. Run `bun test packages/shared` to confirm existing channel-runner and adapter tests still pass.
  </verify>
  <done>
- `DaemonEvent` union includes `channel_health` variant with `channelId`, `healthy`, and `error` fields
- `ChannelRunner` polls `isHealthy()` every 30 seconds
- Health events are deduped: only emitted on state change (tracks last state per adapter slug)
- Health polling timer is cleared in `stopAll()` and `lastHealthState` map is cleared
- All existing tests pass
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck:all` passes with zero errors
2. `bun test packages/shared` passes (no regressions in daemon, channel, or plugin tests)
3. `bun test packages/core` passes (if applicable; core is types-only)
4. Grep for inline `channel?: {` in `packages/shared/src/sessions/types.ts` returns zero hits (all replaced by `ChannelOrigin`)
5. Grep for `channel_health` in `packages/core/src/types/daemon.ts` returns one match
6. Grep for `initializeAll` in `packages/shared/src/daemon/entry.ts` returns one match
</verification>

<success_criteria>
- Three tech debt items resolved: type duplication eliminated, plugin init wired, adapter health surfaced
- Zero type errors across monorepo
- Zero test regressions
- No user-facing changes (internal cleanup only)
</success_criteria>

<output>
After completion, create `.planning/phases/pending/19-tech-debt-cleanup/19-01-SUMMARY.md`
</output>

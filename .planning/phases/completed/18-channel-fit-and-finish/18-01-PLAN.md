---
phase: 18-channel-fit-and-finish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/channels/adapters/slack-adapter.ts
  - packages/shared/src/channels/__tests__/slack-adapter.test.ts
  - packages/shared/src/prompts/system.ts
  - packages/shared/src/agent/craft-agent.ts
  - packages/shared/src/daemon/channel-runner.ts
  - packages/shared/src/channels/session-resolver.ts
  - packages/shared/src/channels/__tests__/session-resolver.test.ts
  - package.json
autonomous: true
must_haves:
  truths:
    - Outbound Slack messages have markdown converted to mrkdwn before posting (bold, italic, strikethrough, links, headings all converted)
    - Messages exceeding 40K chars are truncated with indicator before posting
    - Agent receives channel context in system prompt when responding to a channel session
    - Reset keywords (/reset, /new, reset conversation, start over) create a new session instead of continuing the existing one
    - Direct (non-channel) sessions are unaffected by channel context injection
  artifacts:
    - packages/shared/src/channels/adapters/slack-adapter.ts with markdownToSlack() in send()
    - packages/shared/src/prompts/system.ts with formatChannelContext() export
    - packages/shared/src/agent/craft-agent.ts with optional channel config field
    - packages/shared/src/daemon/channel-runner.ts with reset keyword detection
    - packages/shared/src/channels/session-resolver.ts with resetCounter parameter
  key_links:
    - SlackChannelAdapter.send() -> md-to-slack -> chat.postMessage()
    - CraftAgentConfig.channel -> getSystemPrompt() append -> formatChannelContext()
    - ChannelRunner.handleMessage() -> isResetCommand() -> resolveSessionKey() with reset counter
---

<objective>
Add markdown-to-mrkdwn conversion in SlackChannelAdapter.send(), channel context injection into the agent system prompt, message truncation for Slack's 40K limit, and conversation reset keyword detection in ChannelRunner.

Purpose: Outbound Slack messages render correctly in mrkdwn format, the agent adapts its output style for channel conversations, long messages are safely truncated, and users can start fresh conversations by typing reset keywords.

Output: Modified slack-adapter.ts, system.ts, craft-agent.ts, channel-runner.ts, session-resolver.ts with tests.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/phases/pending/18-channel-fit-and-finish/18-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md

@packages/shared/src/channels/adapters/slack-adapter.ts
@packages/shared/src/channels/__tests__/slack-adapter.test.ts
@packages/shared/src/channels/types.ts
@packages/shared/src/prompts/system.ts
@packages/shared/src/agent/craft-agent.ts
@packages/shared/src/daemon/channel-runner.ts
@packages/shared/src/channels/session-resolver.ts
@packages/shared/src/channels/__tests__/session-resolver.test.ts
@apps/electron/src/main/sessions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install md-to-slack and add markdown conversion + truncation to SlackChannelAdapter.send()</name>
  <files>
    package.json
    packages/shared/src/channels/adapters/slack-adapter.ts
    packages/shared/src/channels/__tests__/slack-adapter.test.ts
  </files>
  <action>
1. Install `md-to-slack` from the monorepo root:
   ```bash
   bun add md-to-slack
   ```
   The `marked` dependency is already installed. The `md-to-slack` package provides `markdownToSlack()` for converting standard markdown to Slack mrkdwn.

2. In `packages/shared/src/channels/adapters/slack-adapter.ts`:
   - Import `markdownToSlack` from `md-to-slack` at the top.
   - Add a `SLACK_MAX_TEXT_LENGTH` constant set to `39_000` (safe margin below Slack's 40K limit).
   - Modify the existing `send()` method to:
     a. Convert `message.content` through `markdownToSlack()` before posting.
     b. After conversion, check length. If the converted text exceeds `SLACK_MAX_TEXT_LENGTH`, truncate at the limit and append `\n\n... (response truncated)`.
     c. Pass the converted/truncated text to `chat.postMessage()`.

   The updated send() method should look like:
   ```typescript
   async send(message: OutboundMessage): Promise<void> {
     if (!this.client) throw new Error('SlackChannelAdapter not configured');

     // Convert standard markdown to Slack mrkdwn
     let text = markdownToSlack(message.content);

     // Truncate if exceeding Slack's text limit
     if (text.length > SLACK_MAX_TEXT_LENGTH) {
       text = text.slice(0, SLACK_MAX_TEXT_LENGTH) + '\n\n... (response truncated)';
     }

     await this.client.chat.postMessage({
       channel: message.channelId,
       text,
       thread_ts: message.threadId,
     });
   }
   ```

3. In the existing test file `packages/shared/src/channels/__tests__/slack-adapter.test.ts`, add tests for the send() conversion:
   - Test that `send()` converts bold markdown (`**text**`) to mrkdwn (`*text*`).
   - Test that `send()` truncates messages exceeding 39K chars with the truncation indicator.
   - Mock `markdownToSlack` if needed, or test end-to-end through the real conversion.

Do NOT change the `toChannelMessage()` method or the polling logic. Only the `send()` method changes.
  </action>
  <verify>
```bash
bun run typecheck:all
bun test packages/shared/src/channels/__tests__/slack-adapter.test.ts
```
Type checks pass. Send tests pass with markdown conversion and truncation.
  </verify>
  <done>
- md-to-slack installed
- SlackChannelAdapter.send() converts markdown to mrkdwn before posting
- Messages exceeding 39K chars are truncated with indicator
- Tests verify conversion and truncation behavior
- typecheck passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add channel context injection to system prompt and conversation reset to ChannelRunner</name>
  <files>
    packages/shared/src/prompts/system.ts
    packages/shared/src/agent/craft-agent.ts
    packages/shared/src/daemon/channel-runner.ts
    packages/shared/src/channels/session-resolver.ts
    packages/shared/src/channels/__tests__/session-resolver.test.ts
  </files>
  <action>
**Part A: Channel context in system prompt**

1. In `packages/shared/src/prompts/system.ts`, add a new exported function `formatChannelContext()`:
   ```typescript
   export function formatChannelContext(channel?: { adapter: string; slug: string }): string {
     if (!channel) return '';
     const label = channel.adapter.charAt(0).toUpperCase() + channel.adapter.slice(1);
     return `\n\n<channel_context adapter="${channel.adapter}" slug="${channel.slug}">
   You are responding through a ${label} channel. Your responses are delivered as ${label} messages, not rendered markdown. Adjust your output:
   - Keep responses concise and conversational
   - Avoid tables (not supported in Slack mrkdwn)
   - Avoid image markdown syntax (not supported)
   - Minimize large code blocks (hard to read in chat)
   - Use simple formatting: bold, italic, code, lists, quotes
   - Do not include HTML tags
   </channel_context>`;
   }
   ```

2. In `packages/shared/src/agent/craft-agent.ts`:
   - Import `formatChannelContext` from `../prompts/system.ts` alongside the existing imports.
   - Add an optional `channel` field to `CraftAgentConfig`:
     ```typescript
     channel?: { adapter: string; slug: string };
     ```
   - In the constructor or wherever `this.config` fields are stored, capture `config.channel`.
   - In the `getSystemPrompt()` call (around line 894 inside the agent options), append the channel context to the system prompt. The cleanest approach: after the current `getSystemPrompt(...)` call result, concatenate `formatChannelContext(this.config.channel)`.
     Change:
     ```typescript
     append: getSystemPrompt(
       this.pinnedPreferencesPrompt ?? undefined,
       this.config.debugMode,
       this.workspaceRootPath,
       this.config.session?.workingDirectory
     ),
     ```
     To:
     ```typescript
     append: getSystemPrompt(
       this.pinnedPreferencesPrompt ?? undefined,
       this.config.debugMode,
       this.workspaceRootPath,
       this.config.session?.workingDirectory
     ) + formatChannelContext(this.config.channel),
     ```
   - This is session-stable (channel never changes within a session), so it lives in the system prompt without breaking resumption.

3. In `apps/electron/src/main/sessions.ts`, in `getOrCreateAgent()` (around line 1488), pass the channel info to the agent config:
   ```typescript
   managed.agent = new CraftAgent({
     ...existing fields...,
     channel: managed.channel ? { adapter: managed.channel.adapter, slug: managed.channel.slug } : undefined,
   })
   ```
   Add `channel` after the `debugMode` field.

**Part B: Conversation reset detection**

4. In `packages/shared/src/daemon/channel-runner.ts`:
   - Add a reset command detection function at module level:
     ```typescript
     const RESET_PATTERNS = [
       /^\/reset$/i,
       /^\/new$/i,
       /^reset\s*conversation$/i,
       /^start\s*over$/i,
     ];

     function isResetCommand(content: string): boolean {
       const trimmed = content.trim();
       return RESET_PATTERNS.some(p => p.test(trimmed));
     }
     ```
   - Add a reset counter map to the `ChannelRunner` class:
     ```typescript
     private resetCounters: Map<string, number> = new Map();
     ```
   - In `handleMessage()`, before `resolveSessionKey()`, check for reset. If the message is a reset command:
     a. Derive a base key from `slug + ':' + workspaceId + ':' + (threadId ?? channelSourceId)`.
     b. Increment the reset counter for that base key.
     c. Pass the reset counter to `resolveSessionKey()` via a new optional `resetSuffix` parameter.
     d. Log the reset and return early (do not enqueue the reset message itself).

   Updated `handleMessage()`:
   ```typescript
   private handleMessage(slug: string, workspaceId: string, msg: ChannelMessage): void {
     const matcher = this.triggerMatchers.get(slug);
     if (matcher && !matcher.matches(msg.content)) {
       this.log(`Message ${msg.id} skipped by trigger filter for ${slug}`);
       return;
     }

     const channelSourceId = msg.channelId;
     const threadKey = msg.replyTo?.threadId ?? channelSourceId;

     // Detect conversation reset
     if (isResetCommand(msg.content)) {
       const baseKey = `${slug}:${workspaceId}:${threadKey}`;
       const count = (this.resetCounters.get(baseKey) ?? 0) + 1;
       this.resetCounters.set(baseKey, count);
       this.log(`Reset command detected for ${slug}, counter=${count}`);
       return; // Do not enqueue the reset keyword itself
     }

     const resetCount = this.resetCounters.get(`${slug}:${workspaceId}:${threadKey}`) ?? 0;
     const sessionKey = resolveSessionKey(slug, workspaceId, msg.replyTo?.threadId, channelSourceId, resetCount);

     msg.metadata.sessionKey = sessionKey;
     msg.metadata.workspaceId = workspaceId;

     this.queue.enqueue('inbound', slug, msg);
     this.emit({ type: 'message_received', channelId: slug, messageId: msg.id });
   }
   ```

   Clear `resetCounters` in `stopAll()`:
   ```typescript
   this.resetCounters.clear();
   ```

5. In `packages/shared/src/channels/session-resolver.ts`, add an optional `resetCount` parameter:
   ```typescript
   export function resolveSessionKey(
     channelSlug: string,
     workspaceId: string,
     threadId: string | undefined,
     channelSourceId: string,
     resetCount: number = 0,
   ): string {
     const threadKey = threadId ?? channelSourceId;
     const suffix = resetCount > 0 ? `:r${resetCount}` : '';
     const input = `${channelSlug}:${workspaceId}:${threadKey}${suffix}`;
     const hash = createHash('sha256').update(input).digest('hex').slice(0, 12);
     return `daemon-${channelSlug}-${hash}`;
   }
   ```

6. In `packages/shared/src/channels/__tests__/session-resolver.test.ts`, add tests:
   - Verify that resetCount=0 produces the same key as the existing behavior (no suffix).
   - Verify that resetCount=1 produces a different key from resetCount=0.
   - Verify that resetCount=1 is deterministic (same inputs produce same output).

Do NOT modify `buildTextPrompt()` or `buildSDKUserMessage()` for channel context. Channel context goes in the system prompt (session-stable, cacheable).
  </action>
  <verify>
```bash
bun run typecheck:all
bun test packages/shared/src/channels/__tests__/session-resolver.test.ts
bun test packages/shared
```
Type checks pass. Session resolver tests cover reset counter. All shared package tests pass.
  </verify>
  <done>
- formatChannelContext() exported from prompts/system.ts
- CraftAgentConfig accepts optional channel field
- System prompt includes channel context when channel is set
- getOrCreateAgent() passes managed.channel to CraftAgent
- isResetCommand() detects /reset, /new, reset conversation, start over
- Reset increments counter and produces new session key via resolveSessionKey
- Reset message itself is not enqueued
- resolveSessionKey() with resetCount=0 is backward-compatible
- All tests pass, typecheck passes
  </done>
</task>

</tasks>

<verification>
```bash
bun run typecheck:all
bun test packages/shared
```

All type checks and existing tests pass. No regressions in daemon, channel, or agent functionality. Channel context only appears for channel sessions. Reset keywords produce new session keys while non-reset messages remain unaffected.
</verification>

<success_criteria>
- SlackChannelAdapter.send() converts markdown to mrkdwn via md-to-slack
- Messages exceeding 39K chars are truncated with indicator
- Channel sessions inject channel_context into the agent system prompt
- Direct (non-channel) sessions have no channel context
- Reset keywords (/reset, /new, reset conversation, start over) create new sessions
- resolveSessionKey() backward-compatible with resetCount=0
- All type checks pass, all existing + new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/pending/18-channel-fit-and-finish/18-01-SUMMARY.md`
</output>

---
phase: 03-core-git-service
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/electron/src/renderer/atoms/git.ts
  - apps/electron/src/renderer/hooks/useGitStatus.ts
autonomous: true

must_haves:
  truths:
    - "Git state is scoped to workspace ID (multi-workspace support)"
    - "Hook returns current branch or null for non-git directories"
    - "Hook triggers fetch when workspace changes"
  artifacts:
    - path: "apps/electron/src/renderer/atoms/git.ts"
      provides: "Workspace-keyed git state atom"
      exports: ["gitStateAtom", "gitStateForWorkspaceAtom"]
    - path: "apps/electron/src/renderer/hooks/useGitStatus.ts"
      provides: "useGitStatus hook for components"
      exports: ["useGitStatus"]
  key_links:
    - from: "apps/electron/src/renderer/hooks/useGitStatus.ts"
      to: "apps/electron/src/renderer/atoms/git.ts"
      via: "useAtom import"
      pattern: "from.*atoms/git"
    - from: "apps/electron/src/renderer/hooks/useGitStatus.ts"
      to: "window.electronAPI.getGitStatus"
      via: "IPC call"
      pattern: "electronAPI\\.getGitStatus"
---

<objective>
Create the renderer-side state management for git status using Jotai atoms.

Purpose: Establish workspace-scoped git state that can be shared across components. The atom stores git status per workspace ID, and the hook provides a convenient interface for components to access current workspace git status and trigger fetches.

Output: `atoms/git.ts` with workspace-keyed state and `hooks/useGitStatus.ts` for component use.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-git-service/03-01-SUMMARY.md
@apps/electron/src/renderer/atoms/sources.ts
@apps/electron/src/renderer/atoms/sessions.ts
@apps/electron/src/renderer/hooks/useStatuses.ts
@apps/electron/src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create git state atom</name>
  <files>apps/electron/src/renderer/atoms/git.ts</files>
  <action>
Create apps/electron/src/renderer/atoms/git.ts with workspace-keyed git state.

```typescript
/**
 * Git State Management with Jotai
 *
 * Stores git status per workspace ID to support multi-workspace scenarios.
 * Each workspace has independent git state (branch, isRepo, etc).
 *
 * Pattern matches existing atoms/sources.ts and atoms/sessions.ts.
 */

import { atom } from 'jotai'
import type { GitState } from '../../shared/types'

/**
 * Map of workspace ID to git state.
 * Key: workspaceId, Value: GitState
 *
 * Using Map ensures workspace isolation - git state from one workspace
 * never leaks to another during rapid workspace switching.
 */
export const gitStateMapAtom = atom<Map<string, GitState>>(new Map())

/**
 * Loading state per workspace (to show loading indicators)
 */
export const gitLoadingMapAtom = atom<Map<string, boolean>>(new Map())

/**
 * Derived atom: Get git state for a specific workspace.
 * Returns null if no state exists for the workspace.
 */
export const gitStateForWorkspaceAtom = atom(
  (get) => (workspaceId: string): GitState | null => {
    const stateMap = get(gitStateMapAtom)
    return stateMap.get(workspaceId) ?? null
  }
)

/**
 * Derived atom: Check if git status is loading for a workspace.
 */
export const gitLoadingForWorkspaceAtom = atom(
  (get) => (workspaceId: string): boolean => {
    const loadingMap = get(gitLoadingMapAtom)
    return loadingMap.get(workspaceId) ?? false
  }
)

/**
 * Action atom: Update git state for a workspace.
 */
export const setGitStateAtom = atom(
  null,
  (get, set, { workspaceId, state }: { workspaceId: string; state: GitState }) => {
    const stateMap = new Map(get(gitStateMapAtom))
    stateMap.set(workspaceId, state)
    set(gitStateMapAtom, stateMap)
  }
)

/**
 * Action atom: Set loading state for a workspace.
 */
export const setGitLoadingAtom = atom(
  null,
  (get, set, { workspaceId, loading }: { workspaceId: string; loading: boolean }) => {
    const loadingMap = new Map(get(gitLoadingMapAtom))
    loadingMap.set(workspaceId, loading)
    set(gitLoadingMapAtom, loadingMap)
  }
)

/**
 * Action atom: Clear git state for a workspace (on workspace removal).
 */
export const clearGitStateAtom = atom(
  null,
  (get, set, workspaceId: string) => {
    const stateMap = new Map(get(gitStateMapAtom))
    const loadingMap = new Map(get(gitLoadingMapAtom))
    stateMap.delete(workspaceId)
    loadingMap.delete(workspaceId)
    set(gitStateMapAtom, stateMap)
    set(gitLoadingMapAtom, loadingMap)
  }
)
```

Key design decisions:
- Map<workspaceId, GitState> ensures workspace isolation (per research requirement)
- Separate loading state atom for UI indicators
- Action atoms for state updates follow existing patterns
- Derived atoms with function return for workspace lookup
  </action>
  <verify>
Run `bun run typecheck:all` - should pass.
Run `ls apps/electron/src/renderer/atoms/git.ts` - file should exist.
  </verify>
  <done>Git state atom created with workspace-keyed state storage</done>
</task>

<task type="auto">
  <name>Task 2: Create useGitStatus hook</name>
  <files>apps/electron/src/renderer/hooks/useGitStatus.ts</files>
  <action>
Create apps/electron/src/renderer/hooks/useGitStatus.ts for component use.

```typescript
/**
 * useGitStatus - Hook for accessing workspace git status
 *
 * Provides git status for the current workspace with automatic fetching.
 * Handles workspace switching by re-fetching when workspaceId changes.
 *
 * Usage:
 *   const { gitState, isLoading, refresh } = useGitStatus(workspaceId, workspaceRootPath)
 */

import { useEffect, useCallback } from 'react'
import { useAtom, useAtomValue, useSetAtom } from 'jotai'
import {
  gitStateForWorkspaceAtom,
  gitLoadingForWorkspaceAtom,
  setGitStateAtom,
  setGitLoadingAtom,
} from '@/atoms/git'
import type { GitState } from '../../shared/types'

interface UseGitStatusResult {
  /** Current git state for the workspace, null if not yet fetched or not a git repo */
  gitState: GitState | null
  /** True if git status is being fetched */
  isLoading: boolean
  /** Manually refresh git status */
  refresh: () => Promise<void>
}

/**
 * Hook to access git status for a workspace.
 *
 * @param workspaceId - Current workspace ID
 * @param workspaceRootPath - Absolute path to workspace root directory
 * @returns Git state, loading state, and refresh function
 */
export function useGitStatus(
  workspaceId: string | null,
  workspaceRootPath: string | null
): UseGitStatusResult {
  const getGitState = useAtomValue(gitStateForWorkspaceAtom)
  const getLoading = useAtomValue(gitLoadingForWorkspaceAtom)
  const setGitState = useSetAtom(setGitStateAtom)
  const setLoading = useSetAtom(setGitLoadingAtom)

  const gitState = workspaceId ? getGitState(workspaceId) : null
  const isLoading = workspaceId ? getLoading(workspaceId) : false

  const refresh = useCallback(async () => {
    if (!workspaceId || !workspaceRootPath) return

    // Set loading state
    setLoading({ workspaceId, loading: true })

    try {
      // Fetch git status via IPC
      const state = await window.electronAPI.getGitStatus(workspaceRootPath)
      setGitState({ workspaceId, state })
    } catch (error) {
      console.error('[useGitStatus] Failed to fetch git status:', error)
      // Set default non-repo state on error
      setGitState({
        workspaceId,
        state: {
          branch: null,
          isRepo: false,
          isDetached: false,
          detachedHead: null,
        },
      })
    } finally {
      setLoading({ workspaceId, loading: false })
    }
  }, [workspaceId, workspaceRootPath, setGitState, setLoading])

  // Fetch git status when workspace changes
  useEffect(() => {
    if (workspaceId && workspaceRootPath) {
      // Only fetch if we don't have state yet for this workspace
      const existingState = getGitState(workspaceId)
      if (!existingState) {
        refresh()
      }
    }
  }, [workspaceId, workspaceRootPath, refresh, getGitState])

  return {
    gitState,
    isLoading,
    refresh,
  }
}
```

Key features:
- Auto-fetches on workspace change (GIT-03: status update when switching)
- Returns null for non-git repos (GIT-02: no indicator for non-git)
- Provides refresh function for manual updates
- Loading state for UI feedback
- Error handling with fallback to non-repo state
  </action>
  <verify>
Run `bun run typecheck:all` - should pass.
Run `ls apps/electron/src/renderer/hooks/useGitStatus.ts` - file should exist.
  </verify>
  <done>useGitStatus hook created with auto-fetch and workspace switching support</done>
</task>

</tasks>

<verification>
1. `bun run typecheck:all` passes
2. `apps/electron/src/renderer/atoms/git.ts` exports workspace-keyed atoms
3. `apps/electron/src/renderer/hooks/useGitStatus.ts` exports useGitStatus hook
4. Hook handles null workspaceId/path gracefully
5. State is isolated per workspace (Map<workspaceId, GitState>)
</verification>

<success_criteria>
- gitStateMapAtom stores workspace-keyed git state
- gitLoadingMapAtom tracks loading state per workspace
- useGitStatus hook auto-fetches when workspace changes
- useGitStatus returns null gitState for non-git directories
- Loading state available for UI indicators
- Manual refresh function available
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-git-service/03-03-SUMMARY.md`
</output>

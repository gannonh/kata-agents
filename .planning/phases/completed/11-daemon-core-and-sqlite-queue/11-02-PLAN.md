---
phase: 11-daemon-core-and-sqlite-queue
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - packages/shared/src/daemon/entry.ts
  - packages/shared/src/daemon/pid.ts
  - packages/shared/src/daemon/index.ts
  - apps/electron/src/main/daemon-manager.ts
  - apps/electron/src/main/index.ts
  - apps/electron/src/main/ipc.ts
autonomous: true
source_issue: ""

must_haves:
  truths:
    - "DaemonManager spawns a Bun subprocess running packages/shared/src/daemon/entry.ts"
    - "DaemonManager sends DaemonCommand objects as JSON-lines to daemon stdin"
    - "DaemonManager receives DaemonEvent objects as JSON-lines from daemon stdout"
    - "Daemon emits status_changed events (starting -> running -> stopping -> stopped)"
    - "Daemon exits gracefully when stdin closes (parent crash/quit)"
    - "Supervisor restarts daemon on unexpected exit with exponential backoff (1s, 2s, 4s... max 30s)"
    - "Supervisor pauses after 5 consecutive failures"
    - "Stale PID file is detected and cleaned up on app startup"
    - "DaemonManager stops daemon during before-quit lifecycle"
    - "DaemonManager serializes start/stop to prevent concurrent daemon instances"
  artifacts:
    - path: "apps/electron/src/main/daemon-manager.ts"
      provides: "DaemonManager class with start/stop/sendCommand/getState"
    - path: "packages/shared/src/daemon/entry.ts"
      provides: "Daemon entry point that reads stdin commands, emits stdout events, initializes MessageQueue"
    - path: "packages/shared/src/daemon/index.ts"
      provides: "Updated barrel with pid.ts re-exports"
    - path: "packages/shared/src/daemon/pid.ts"
      provides: "writePidFile/cleanupStaleDaemon/removePidFile utilities"
  key_links:
    - from: "apps/electron/src/main/daemon-manager.ts"
      to: "packages/shared/src/daemon/entry.ts"
      via: "child_process.spawn(bunPath, ['run', daemonScript])"
      pattern: "spawn.*daemon"
    - from: "apps/electron/src/main/daemon-manager.ts"
      to: "apps/electron/src/main/index.ts"
      via: "before-quit lifecycle hook"
      pattern: "daemonManager.*stop|before-quit"
    - from: "packages/shared/src/daemon/entry.ts"
      to: "packages/shared/src/daemon/message-queue.ts"
      via: "MessageQueue constructor"
      pattern: "new MessageQueue"
    - from: "packages/shared/src/daemon/entry.ts"
      to: "packages/shared/src/daemon/ipc.ts"
      via: "createLineParser and formatMessage"
      pattern: "createLineParser|formatMessage"
---

<objective>
Wire up the daemon subprocess lifecycle: spawn from Electron, bidirectional JSON-lines communication, crash recovery with exponential backoff, PID file management, and graceful shutdown.

Purpose: This plan connects the data layer (Plan 01) to the process layer. After this plan, the daemon can be started, stopped, restarted on crash, and cleaned up on quit. Channel adapters and plugins (Phase 12+) will plug into this running daemon.

Output: Working DaemonManager in Electron main process, daemon entry point in shared package, PID file utilities, and integration with Electron lifecycle.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/11-daemon-core-and-sqlite-queue/11-RESEARCH.md
@.planning/phases/pending/11-daemon-core-and-sqlite-queue/11-01-SUMMARY.md
@packages/core/src/types/daemon.ts
@packages/shared/src/daemon/types.ts
@packages/shared/src/daemon/ipc.ts
@packages/shared/src/daemon/message-queue.ts
@packages/shared/src/agent/options.ts
@apps/electron/src/main/index.ts
@apps/electron/src/main/sessions.ts (first 100 lines for import patterns)
@packages/shared/src/config/paths.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: PID file utilities and daemon entry point</name>
  <files>
    packages/shared/src/daemon/pid.ts
    packages/shared/src/daemon/index.ts
  </files>
  <action>
**Create `packages/shared/src/daemon/pid.ts`:**
PID file management for stale process cleanup.

```typescript
import { existsSync, readFileSync, writeFileSync, unlinkSync } from 'fs';
import { join } from 'path';
```

Functions:
- `getPidFilePath(configDir: string): string` - returns `join(configDir, 'daemon.pid')`
- `writePidFile(configDir: string, pid: number): void` - writes PID as string to file
- `removePidFile(configDir: string): void` - removes PID file if it exists (try/catch, no throw)
- `cleanupStaleDaemon(configDir: string): void`:
  1. If no PID file exists, return
  2. Read PID from file, parse as integer
  3. If NaN, delete file and return
  4. Try `process.kill(pid, 0)` to check if process exists
  5. If process exists, send `SIGTERM` to kill it. Log to stderr: `[daemon] Killed stale daemon process ${pid}`
  6. If process doesn't exist (catch block), it's a stale PID file
  7. Delete PID file in all cases

**Update `packages/shared/src/daemon/index.ts`** to be the daemon entry point (runs in Bun subprocess):

The entry point must:
1. Resolve config dir from `KATA_CONFIG_DIR` env var (fall back to `~/.kata-agents/`)
2. Write PID file: `writePidFile(configDir, process.pid)`
3. Create a `log()` function that writes to stderr (NOT stdout): `process.stderr.write(\`[daemon] \${msg}\\n\`)`
4. Create an `emit()` function using `formatMessage()` from `./ipc` that writes to `process.stdout`
5. Emit `{ type: 'status_changed', status: 'starting' }` as DaemonEvent
6. Initialize MessageQueue with `join(configDir, 'daemon.db')`
7. Emit `{ type: 'status_changed', status: 'running' }` as DaemonEvent
8. Read stdin using `Bun.stdin.stream().getReader()` in a loop
9. Use `createLineParser()` from `./ipc` to parse incoming JSON-lines
10. For each parsed line, `JSON.parse()` it as a `DaemonCommand` and handle:
    - `type: 'stop'` -> break out of read loop
    - `type: 'health_check'` -> emit `{ type: 'status_changed', status: 'running' }`
    - `type: 'start'` -> no-op (already running)
    - `type: 'plugin_action'` -> log and ignore for Phase 11 (plugins come in Phase 13)
11. When stdin closes (reader returns `done: true`), exit the read loop (parent died)
12. Emit `{ type: 'status_changed', status: 'stopping' }`
13. Close MessageQueue
14. Remove PID file
15. Emit `{ type: 'status_changed', status: 'stopped' }`
16. Wrap `main()` in `.catch()` that writes error to stderr and exits with code 1

**Update barrel export** in `packages/shared/src/daemon/index.ts`:
Wait - the entry point IS index.ts. This creates a conflict with barrel exports. Solution: rename the barrel to a separate file OR make index.ts serve dual purpose.

Better approach: The daemon entry point should be a separate file that is NOT the barrel.

- Rename: `packages/shared/src/daemon/index.ts` (barrel) stays as barrel
- Create: `packages/shared/src/daemon/entry.ts` as the daemon entry point

The DaemonManager will spawn `bun run packages/shared/src/daemon/entry.ts`.

Update the barrel `index.ts` to also export from `./pid` (the `cleanupStaleDaemon` function is needed by DaemonManager).

Do NOT export the entry point from the barrel. It's a standalone script, not a library module.
  </action>
  <verify>
`bun run typecheck:all` passes. `packages/shared/src/daemon/entry.ts` exists. PID file functions are importable from `@craft-agent/shared/daemon`.
  </verify>
  <done>
Daemon entry point reads stdin commands, emits stdout events, initializes MessageQueue, handles graceful shutdown on stdin close. PID file utilities manage stale process cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: DaemonManager with supervisor and Electron integration</name>
  <files>
    apps/electron/src/main/daemon-manager.ts
    apps/electron/src/main/index.ts
    apps/electron/src/main/ipc.ts
  </files>
  <action>
**Create `apps/electron/src/main/daemon-manager.ts`:**

Import `spawn` from `child_process`, `join` from `path`, types from `@craft-agent/core/types` (`DaemonCommand`, `DaemonEvent`, `DaemonStatus`), `createLineParser` from `@craft-agent/shared/daemon`, and `cleanupStaleDaemon` from `@craft-agent/shared/daemon`.

State machine type: `type DaemonManagerState = 'stopped' | 'starting' | 'running' | 'stopping' | 'error' | 'paused'`

Class `DaemonManager`:

**Constructor params:**
- `bunPath: string` - path to Bun executable
- `daemonScript: string` - path to `packages/shared/src/daemon/entry.ts`
- `configDir: string` - path to config dir (passed as KATA_CONFIG_DIR env)
- `onEvent: (event: DaemonEvent) => void` - callback for daemon events
- `onStateChange: (state: DaemonManagerState) => void` - callback for manager state changes

**Private fields:**
- `process: ChildProcess | null`
- `state: DaemonManagerState = 'stopped'`
- `lineParser` - created from `createLineParser`
- `consecutiveFailures = 0`
- `lastStartTime = 0`
- `restartTimer: NodeJS.Timeout | null = null`
- `stopPromise: Promise<void> | null = null`
- `stopResolve: (() => void) | null = null`

**Constants (private static):**
- `BASE_DELAY_MS = 1000`
- `MAX_DELAY_MS = 30_000`
- `MAX_CONSECUTIVE_FAILURES = 5`
- `STABILITY_THRESHOLD_MS = 60_000` (if daemon runs >60s, reset failure counter)
- `GRACEFUL_SHUTDOWN_TIMEOUT_MS = 5000`

**Methods:**

`async start(): Promise<void>`:
1. If state is `stopping`, await `this.stopPromise`
2. If state is `running` or `starting`, return (idempotent)
3. Call `cleanupStaleDaemon(this.configDir)` on first start
4. Set state to `starting`, emit state change
5. Record `lastStartTime = Date.now()`
6. Spawn: `spawn(this.bunPath, ['run', this.daemonScript], { stdio: ['pipe', 'pipe', 'pipe'], env: { ...process.env, KATA_CONFIG_DIR: this.configDir } })`
7. Set up stdout listener: `this.process.stdout.on('data', chunk => this.lineParser(chunk.toString()))`
8. Set up stderr listener: `this.process.stderr.on('data', chunk => console.error(\`[daemon] \${chunk.toString().trimEnd()}\`))`
9. Set up exit listener: `this.process.on('exit', (code, signal) => this.handleExit(code, signal))`
10. Send `{ type: 'start' }` command

`sendCommand(cmd: DaemonCommand): void`:
- Guard: if process stdin is not writable, return
- Write `JSON.stringify(cmd) + '\n'` to process stdin

`async stop(): Promise<void>`:
1. If state is `stopped` or `stopping`, return
2. Cancel any pending restart timer
3. Set state to `stopping`, emit state change
4. Create `stopPromise` with stored resolver
5. Send `{ type: 'stop' }` command
6. Set a timeout: after GRACEFUL_SHUTDOWN_TIMEOUT_MS, if process still alive, SIGTERM it
7. Await `stopPromise`
8. Clear the timeout

`getState(): DaemonManagerState` - returns current state

`private handleEvent(line: string)`:
1. Try `JSON.parse(line)` as DaemonEvent
2. If `type === 'status_changed' && status === 'running'`: set state to `running`, emit state change, reset consecutive failures if appropriate
3. Forward event to `onEvent` callback
4. Catch parse errors: log to console.error

`private handleExit(code: number | null, signal: string | null)`:
1. `this.process = null`
2. If state was `stopping`: set state to `stopped`, resolve `stopPromise`, emit state change, return
3. Check uptime: if `Date.now() - lastStartTime > STABILITY_THRESHOLD_MS`, reset `consecutiveFailures` to 0
4. Increment `consecutiveFailures`
5. If `consecutiveFailures > MAX_CONSECUTIVE_FAILURES`: set state to `paused`, emit state change, log warning, return
6. Compute delay: `Math.min(BASE_DELAY_MS * Math.pow(2, consecutiveFailures - 1), MAX_DELAY_MS)`
7. Log: `[daemon] Exited (code=${code}, signal=${signal}). Restarting in ${delay}ms (attempt ${consecutiveFailures}/${MAX_CONSECUTIVE_FAILURES})`
8. Set state to `error`, emit state change
9. Set `restartTimer = setTimeout(() => this.start(), delay)`

`private cancelPendingRestart()`:
- If `restartTimer`, clear it and set to null

`reset()`: Public method to reset failure counter and allow restart from paused state.
- Set `consecutiveFailures = 0`
- If state is `paused`, set state to `stopped`

Initialize the `lineParser` in the constructor: `this.lineParser = createLineParser((line) => this.handleEvent(line))`

**Integrate into `apps/electron/src/main/index.ts`:**

1. Import `DaemonManager` from `./daemon-manager`
2. Declare `let daemonManager: DaemonManager | null = null` alongside the existing `sessionManager`
3. In the app initialization (after `sessionManager` is created, around the `app.whenReady()` block):
   - Resolve the Bun binary path. Look at how `getDefaultOptions()` in `options.ts` resolves the executable. For the daemon, use the same pattern:
     - In packaged app: `customExecutable` (set via `setExecutable()` in `sessions.ts`)
     - In dev: `'bun'` (assumes bun is on PATH)
   - Resolve daemon script path: `join(__dirname, '../../packages/shared/src/daemon/entry.ts')` in dev, or the appropriate bundled path in packaged app. For now (Phase 11), use the dev path. Packaged app path will be addressed when building distribution.
   - Create DaemonManager instance with event/state callbacks
   - Do NOT auto-start the daemon yet. Phase 12+ will trigger daemon start when channels are configured.

4. In the `before-quit` handler (existing block in index.ts):
   - After `sessionManager.flushAllSessions()`, add:
   ```typescript
   if (daemonManager) {
     try {
       await daemonManager.stop()
       mainLog.info('Daemon stopped')
     } catch (error) {
       mainLog.error('Failed to stop daemon:', error)
     }
   }
   ```

**Register IPC handlers in `apps/electron/src/main/ipc.ts`:**

Add two IPC handlers (follow existing patterns):
- `DAEMON_START` -> calls `daemonManager.start()` and returns state
- `DAEMON_STOP` -> calls `daemonManager.stop()` and returns state
- `DAEMON_STATUS` -> returns `daemonManager.getState()`

Add these channel names to the shared IPC_CHANNELS constant if it exists, or use string literals with a comment noting they should be added to IPC_CHANNELS in a future PR.

The DaemonManager instance needs to be accessible from ipc.ts. Pass it as a parameter to `registerIpcHandlers` (same pattern as `sessionManager` is passed), or use a module-level setter. Follow whichever pattern the existing code uses for sessionManager access.
  </action>
  <verify>
1. `bun run typecheck:all` passes
2. `bun run lint:electron` passes (or has only pre-existing warnings)
3. In development, `bun run electron:dev` starts without errors related to daemon-manager imports
4. DaemonManager class exports correctly from `apps/electron/src/main/daemon-manager.ts`
5. The before-quit handler includes daemon shutdown
  </verify>
  <done>
DaemonManager spawns Bun subprocess, exchanges JSON-lines messages, restarts on crash with exponential backoff, cleans up stale PIDs, and shuts down during Electron before-quit. IPC handlers registered for daemon start/stop/status.
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck:all` passes
2. `bun test packages/shared/src/daemon/` passes all tests from Plan 01 (no regressions)
3. `bun test` (full suite) passes
4. `bun run lint:electron` passes
5. DaemonManager state machine transitions: stopped -> starting -> running -> stopping -> stopped
6. DaemonManager restart logic: error -> delay -> starting -> running (or paused after 5 failures)
7. Daemon entry point exits when stdin closes
8. PID file is written on daemon start, removed on daemon stop
9. Stale PID cleanup runs before first daemon spawn
</verification>

<success_criteria>
- DaemonManager spawns a Bun subprocess and exchanges JSON messages over stdin/stdout (DAEMON-01)
- Daemon restarts with exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s, pauses after 5 failures (DAEMON-02)
- SQLite database at daemon.db with WAL mode (verified in Plan 01) is initialized by daemon entry point (DAEMON-05)
- Stale daemon PID cleanup on app startup
- Daemon stops cleanly during Electron before-quit
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/pending/11-daemon-core-and-sqlite-queue/11-02-SUMMARY.md`
</output>

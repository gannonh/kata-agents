---
phase: 11-daemon-core-and-sqlite-queue
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/daemon/types.ts
  - packages/shared/src/daemon/ipc.ts
  - packages/shared/src/daemon/message-queue.ts
  - packages/shared/src/daemon/index.ts
  - packages/shared/src/daemon/__tests__/ipc.test.ts
  - packages/shared/src/daemon/__tests__/message-queue.test.ts
  - packages/shared/package.json
autonomous: true
source_issue: ""

must_haves:
  truths:
    - "SQLite database initializes with WAL mode and messages table"
    - "enqueue inserts a message and returns its integer ID"
    - "dequeue atomically claims the oldest pending message and returns it"
    - "dequeue returns null when no pending messages exist"
    - "markProcessed transitions a message from processing to processed"
    - "markFailed transitions a message to failed with error text and increments retry_count"
    - "JSON-lines parser handles partial chunks, multi-line chunks, and empty lines"
    - "JSON-lines emitter writes valid NDJSON to stdout"
  artifacts:
    - path: "packages/shared/src/daemon/message-queue.ts"
      provides: "MessageQueue class with enqueue/dequeue/markProcessed/markFailed/close"
    - path: "packages/shared/src/daemon/ipc.ts"
      provides: "createLineParser() and emitEvent() for JSON-lines IPC"
    - path: "packages/shared/src/daemon/types.ts"
      provides: "Re-exports of core daemon types plus daemon-internal types (QueuedMessage, MessageDirection, MessageStatus)"
    - path: "packages/shared/src/daemon/__tests__/message-queue.test.ts"
      provides: "Unit tests for MessageQueue CRUD operations"
    - path: "packages/shared/src/daemon/__tests__/ipc.test.ts"
      provides: "Unit tests for JSON-lines parsing edge cases"
  key_links:
    - from: "packages/shared/src/daemon/message-queue.ts"
      to: "bun:sqlite"
      via: "Database import"
      pattern: "import.*Database.*from.*bun:sqlite"
    - from: "packages/shared/src/daemon/types.ts"
      to: "packages/core/src/types/daemon.ts"
      via: "re-export"
      pattern: "export.*from.*@craft-agent/core"
---

<objective>
Build the SQLite message queue and JSON-lines IPC module for the daemon subprocess.

Purpose: These two modules are the data layer and communication protocol that the daemon entry point (Plan 02) and DaemonManager (Plan 02) will use. Building and testing them in isolation ensures the foundation is solid before wiring up process lifecycle.

Output: Tested MessageQueue class, tested IPC line parser, and daemon-internal type definitions. Subpath export `@craft-agent/shared/daemon` registered.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/11-daemon-core-and-sqlite-queue/11-RESEARCH.md
@packages/core/src/types/daemon.ts
@packages/shared/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Daemon internal types and subpath export</name>
  <files>
    packages/shared/src/daemon/types.ts
    packages/shared/src/daemon/index.ts
    packages/shared/package.json
  </files>
  <action>
Create `packages/shared/src/daemon/types.ts`:
- Re-export `DaemonStatus`, `DaemonCommand`, `DaemonEvent` from `@craft-agent/core/types`
- Define `MessageDirection = 'inbound' | 'outbound'`
- Define `MessageStatus = 'pending' | 'processing' | 'processed' | 'failed'`
- Define `QueuedMessage` interface: `{ id: number; direction: MessageDirection; channelId: string; status: MessageStatus; payload: unknown; createdAt: string; processedAt: string | null; error: string | null; retryCount: number }`

Create `packages/shared/src/daemon/index.ts` as a barrel that re-exports from `./types`, `./message-queue`, and `./ipc`.

Add subpath export to `packages/shared/package.json`:
```json
"./daemon": {
  "types": "./src/daemon/index.ts",
  "import": "./src/daemon/index.ts",
  "default": "./src/daemon/index.ts"
}
```

Follow the existing pattern in package.json (see `./agent`, `./config`, etc.).
  </action>
  <verify>
`bun run typecheck:all` passes. The new types are importable via `import type { QueuedMessage } from '@craft-agent/shared/daemon'`.
  </verify>
  <done>
Daemon-internal types defined. Subpath export registered. Typecheck passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: SQLite message queue with TDD</name>
  <files>
    packages/shared/src/daemon/message-queue.ts
    packages/shared/src/daemon/__tests__/message-queue.test.ts
  </files>
  <action>
**RED phase first.** Write tests in `packages/shared/src/daemon/__tests__/message-queue.test.ts` before implementation.

Test cases to write:
1. `creates database with WAL mode` - open DB, query `PRAGMA journal_mode`, assert `wal`
2. `creates messages table` - query `sqlite_master` for `messages` table
3. `enqueue returns integer ID` - enqueue a message, assert return is a positive integer
4. `dequeue returns oldest pending message` - enqueue 3 messages, dequeue returns first
5. `dequeue returns null when empty` - dequeue on empty queue returns null
6. `dequeue atomically sets status to processing` - dequeue, then query status directly
7. `markProcessed sets status` - enqueue, dequeue, markProcessed, query row
8. `markFailed sets error and increments retryCount` - enqueue, dequeue, markFailed, query row
9. `dequeue skips processing messages` - enqueue 2, dequeue first, dequeue should return second
10. `close closes database` - close, verify no errors

Use a temp directory for test databases (`import { tmpdir } from 'os'`; `join(tmpdir(), \`test-daemon-\${Date.now()}.db\`)`). Clean up in afterEach.

**GREEN phase.** Implement `packages/shared/src/daemon/message-queue.ts`:
- `MessageQueue` class constructor takes `dbPath: string`
- Constructor: open `Database` from `bun:sqlite`, set PRAGMAs (journal_mode=WAL, busy_timeout=5000, synchronous=NORMAL), create table and indices
- Use prepared statements (`.query()`) for all operations, stored as private fields
- `enqueue(direction, channelId, payload)` - returns `number` (lastInsertRowid)
- `dequeue(direction)` - uses `UPDATE ... WHERE id = (SELECT ...) RETURNING *`, returns `QueuedMessage | null`
- `markProcessed(id)` - updates status to `processed`
- `markFailed(id, error)` - updates status to `failed`, sets error, increments retry_count
- `close()` - closes the database

Schema (from research):
```sql
CREATE TABLE IF NOT EXISTS messages (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  direction TEXT NOT NULL CHECK(direction IN ('inbound', 'outbound')),
  channel_id TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK(status IN ('pending', 'processing', 'processed', 'failed')),
  payload TEXT NOT NULL,
  created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
  processed_at TEXT,
  error TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0
)
```

Indices:
- `idx_messages_pending ON messages (direction, status, created_at) WHERE status = 'pending'`
- `idx_messages_channel ON messages (channel_id, direction, created_at)`

**REFACTOR phase.** Clean up naming, ensure all tests pass.

Important: The `dequeue` method must parse the `payload` field from JSON string back to the original object. The `enqueue` method must `JSON.stringify` the payload before insertion.
  </action>
  <verify>
`bun test packages/shared/src/daemon/__tests__/message-queue.test.ts` passes all 10 tests. `bun run typecheck:all` passes.
  </verify>
  <done>
MessageQueue class implements enqueue/dequeue/markProcessed/markFailed with SQLite WAL mode. All 10 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: JSON-lines IPC module with TDD</name>
  <files>
    packages/shared/src/daemon/ipc.ts
    packages/shared/src/daemon/__tests__/ipc.test.ts
  </files>
  <action>
**RED phase first.** Write tests in `packages/shared/src/daemon/__tests__/ipc.test.ts`.

The IPC module provides two things:
1. `createLineParser(onLine: (line: string) => void)` - returns `(chunk: string) => void`. Buffers input, splits on `\n`, calls `onLine` for each complete line. Handles partial chunks, multiple lines in one chunk, and empty lines.
2. `formatMessage(msg: unknown): string` - returns `JSON.stringify(msg) + '\n'`

Test cases:
1. `parses complete single-line message` - feed `'{"type":"start"}\n'`, callback receives `'{"type":"start"}'`
2. `parses multiple lines in one chunk` - feed `'{"a":1}\n{"b":2}\n'`, callback called twice
3. `handles partial chunks` - feed `'{"type":"st'` then `'art"}\n'`, callback called once with complete line
4. `skips empty lines` - feed `'\n\n{"a":1}\n\n'`, callback called once
5. `handles chunk split mid-character` - feed `'{"msg":"hello'` then `' world"}\n'`, callback receives full JSON
6. `does not call callback for incomplete trailing data` - feed `'{"partial":true'` (no newline), callback not called
7. `formatMessage appends newline` - assert result ends with `\n`
8. `formatMessage produces valid JSON before newline` - parse result minus trailing newline

**GREEN phase.** Implement `packages/shared/src/daemon/ipc.ts`:

```typescript
export function createLineParser(onLine: (line: string) => void): (chunk: string) => void {
  let buffer = '';
  return (chunk: string) => {
    buffer += chunk;
    let idx: number;
    while ((idx = buffer.indexOf('\n')) !== -1) {
      const line = buffer.slice(0, idx).trim();
      buffer = buffer.slice(idx + 1);
      if (line) {
        onLine(line);
      }
    }
  };
}

export function formatMessage(msg: unknown): string {
  return JSON.stringify(msg) + '\n';
}
```

This is intentionally simple. The research warns against over-engineering the line parser. The critical detail is the buffer that handles partial chunks.

**REFACTOR phase.** Ensure naming is consistent with the rest of the codebase.
  </action>
  <verify>
`bun test packages/shared/src/daemon/__tests__/ipc.test.ts` passes all 8 tests. `bun run typecheck:all` passes.
  </verify>
  <done>
IPC line parser and message formatter implemented. All 8 tests pass. Partial chunk buffering verified.
  </done>
</task>

</tasks>

<verification>
1. `bun run typecheck:all` passes with zero errors
2. `bun test packages/shared/src/daemon/` runs all tests (message-queue + ipc) and all pass
3. `packages/shared/src/daemon/index.ts` exports MessageQueue, createLineParser, formatMessage, and all types
4. No runtime code imports from `apps/electron/` (these are shared package modules)
5. `bun test` (full suite) still passes - no regressions
</verification>

<success_criteria>
- MessageQueue class creates SQLite DB with WAL mode, enqueues/dequeues/marks messages
- JSON-lines parser handles all chunk boundary edge cases
- All tests pass (18+ tests across 2 test files)
- Types and subpath export are registered and importable
- No new dependencies added (bun:sqlite is built-in, zod already in deps)
</success_criteria>

<output>
After completion, create `.planning/phases/pending/11-daemon-core-and-sqlite-queue/11-01-SUMMARY.md`
</output>

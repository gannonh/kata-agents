---
phase: 12-channel-adapters
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - packages/shared/src/channels/adapters/slack-adapter.ts
  - packages/shared/src/channels/adapters/index.ts
  - packages/shared/src/channels/index.ts
  - packages/shared/src/channels/__tests__/slack-adapter.test.ts
  - packages/shared/src/daemon/channel-runner.ts
  - packages/shared/src/daemon/entry.ts
  - packages/shared/src/daemon/index.ts
  - packages/shared/src/daemon/__tests__/channel-runner.test.ts
  - packages/core/src/types/daemon.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Slack adapter polls conversations.history with oldest timestamp and enqueues new messages"
    - "Slack adapter skips messages from the bot itself (prevents self-reply loops)"
    - "Slack adapter converts Slack messages to ChannelMessage format"
    - "Slack adapter reports health status and last error"
    - "Slack adapter persists polling state to SQLite for restart resilience"
    - "Channel-runner starts and stops adapters based on ChannelConfig"
    - "Channel-runner applies TriggerMatcher before enqueuing messages"
    - "Channel-runner resolves session keys via ChannelSessionResolver"
    - "Daemon entry point loads channel configs and starts channel-runner"
  artifacts:
    - path: "packages/shared/src/channels/adapters/slack-adapter.ts"
      provides: "SlackChannelAdapter implementing ChannelAdapter"
      exports: ["SlackChannelAdapter"]
    - path: "packages/shared/src/daemon/channel-runner.ts"
      provides: "ChannelRunner orchestrating adapter lifecycle"
      exports: ["ChannelRunner"]
    - path: "packages/shared/src/channels/adapters/index.ts"
      provides: "Adapter registry/factory"
      exports: ["createAdapter"]
  key_links:
    - from: "packages/shared/src/channels/adapters/slack-adapter.ts"
      to: "@slack/web-api WebClient"
      via: "import { WebClient } from '@slack/web-api'"
      pattern: "WebClient"
    - from: "packages/shared/src/channels/adapters/slack-adapter.ts"
      to: "packages/shared/src/daemon/message-queue.ts"
      via: "setPollingState/getPollingState for restart resilience"
      pattern: "PollingState"
    - from: "packages/shared/src/daemon/channel-runner.ts"
      to: "packages/shared/src/channels/trigger-matcher.ts"
      via: "import and use TriggerMatcher"
      pattern: "TriggerMatcher"
    - from: "packages/shared/src/daemon/channel-runner.ts"
      to: "packages/shared/src/channels/session-resolver.ts"
      via: "import and use ChannelSessionResolver"
      pattern: "resolveSessionKey"
    - from: "packages/shared/src/daemon/channel-runner.ts"
      to: "packages/shared/src/daemon/message-queue.ts"
      via: "enqueue inbound messages"
      pattern: "queue\\.enqueue"
    - from: "packages/shared/src/daemon/entry.ts"
      to: "packages/shared/src/daemon/channel-runner.ts"
      via: "instantiate and start ChannelRunner"
      pattern: "ChannelRunner"
---

<objective>
Implement the Slack channel adapter with conversations.history polling, the channel-runner that orchestrates adapter lifecycle within the daemon, and wire both into the daemon entry point.

Purpose: This delivers CHAN-01 (Slack adapter) and wires the daemon to process inbound channel messages with trigger filtering and session resolution.
Output: Working Slack polling adapter, channel-runner daemon component, updated daemon entry point.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/pending/12-channel-adapters/12-RESEARCH.md
@.planning/phases/pending/12-channel-adapters/12-01-PLAN.md
@packages/shared/src/channels/types.ts
@packages/shared/src/channels/index.ts
@packages/shared/src/daemon/entry.ts
@packages/shared/src/daemon/message-queue.ts
@packages/shared/src/daemon/types.ts
@packages/shared/src/daemon/index.ts
@packages/core/src/types/daemon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SlackChannelAdapter and adapter registry</name>
  <files>
    packages/shared/src/channels/adapters/slack-adapter.ts
    packages/shared/src/channels/adapters/index.ts
    packages/shared/src/channels/__tests__/slack-adapter.test.ts
    packages/shared/src/channels/index.ts
    package.json
  </files>
  <action>
    **Install dependency:**
    ```bash
    bun add @slack/web-api
    ```

    **Create `packages/shared/src/channels/adapters/slack-adapter.ts`:**

    SlackChannelAdapter implements the ChannelAdapter interface from `../types.ts`.

    Properties:
    - `readonly id: string` — set from config.slug in start()
    - `readonly name = 'Slack'`
    - `readonly type = 'poll' as const`
    - `private client: WebClient | null`
    - `private pollTimer: ReturnType<typeof setInterval> | null`
    - `private lastTimestamps: Map<string, string>` — channelSourceId -> Slack ts
    - `private botUserId: string | null` — resolved at start via auth.test
    - `private botId: string | null` — resolved at start via auth.test
    - `private healthy: boolean`
    - `private lastErrorMsg: string | null`
    - `private pollingStateFns: { get, set } | null` — optional callbacks for persisting polling state

    Constructor: Takes optional `pollingState?: { get: (adapterId: string, channelSourceId: string) => string | null; set: (adapterId: string, channelSourceId: string, ts: string) => void }` parameter. This decouples the adapter from MessageQueue directly.

    `start(config, onMessage)`:
    1. Store config.slug as this.id
    2. Resolve bot token from config. For now, expect `config.credentials.sourceSlug` to reference a source whose credential is the bot token (xoxb-). The adapter receives the token as a second parameter to start, or resolve it from a token resolver callback. **Simplification for Phase 12:** Add `token` field to start signature as `start(config: ChannelConfig, onMessage: (msg: ChannelMessage) => void, token: string): Promise<void>`. This avoids coupling to the credential manager directly. Update the ChannelAdapter interface to NOT change (keep the existing two-param signature), and instead make SlackChannelAdapter.start accept 3 params (it satisfies ChannelAdapter because extra params are allowed in implementations).

    Actually, keep the ChannelAdapter interface unchanged. Instead, provide the token via a `configure(token: string, pollingState?)` method called before start:

    ```typescript
    configure(token: string, pollingState?: { get: ..., set: ... }): void {
      this.client = new WebClient(token, { retryConfig: { retries: 3 } });
      this.pollingStateFns = pollingState ?? null;
    }
    ```

    3. Call `client.auth.test()` to get botUserId and botId. Store both.
    4. If pollingStateFns provided, load lastTimestamps from polling state for each channelId in config.filter.channelIds.
    5. Set `this.healthy = true`.
    6. Start poll interval: `setInterval(() => this.poll(config, onMessage), config.pollIntervalMs ?? 10_000)`.
    7. Run initial poll immediately.

    `poll(config, onMessage)`:
    1. For each channelId in `config.filter?.channelIds ?? []`:
       - Call `client.conversations.history({ channel: channelId, oldest: lastTimestamps.get(channelId), inclusive: false, limit: 100 })`
       - Filter: skip messages where `msg.bot_id === this.botId` or `msg.user === this.botUserId`
       - Convert each remaining message to ChannelMessage via `toChannelMessage(channelId, msg)`
       - Messages come newest-first from Slack. Reverse to process chronologically.
       - Call onMessage for each.
       - Update lastTimestamps with the newest message ts (messages[0].ts after receiving, before reversing).
       - If pollingStateFns, call set to persist.
    2. Wrap in try/catch. On error: set `this.healthy = false`, `this.lastErrorMsg = error.message`.

    `toChannelMessage(channelId, msg)` -> ChannelMessage:
    ```typescript
    {
      id: msg.ts!,
      channelId: this.id,
      source: msg.user ?? 'unknown',
      timestamp: parseFloat(msg.ts!) * 1000,
      content: msg.text ?? '',
      metadata: { slackChannel: channelId, team: msg.team },
      replyTo: msg.thread_ts && msg.thread_ts !== msg.ts ? {
        threadId: msg.thread_ts,
        messageId: msg.ts!,
      } : undefined,
    }
    ```

    `stop()`: clearInterval, set client to null, set healthy to false.
    `isHealthy()`: return this.healthy.
    `getLastError()`: return this.lastErrorMsg.

    **Create `packages/shared/src/channels/adapters/index.ts`:**
    Simple factory:
    ```typescript
    import { SlackChannelAdapter } from './slack-adapter.ts';
    export { SlackChannelAdapter };
    export function createAdapter(type: string): ChannelAdapter | null {
      switch (type) {
        case 'slack': return new SlackChannelAdapter();
        default: return null;
      }
    }
    ```

    **Update `packages/shared/src/channels/index.ts`:**
    Add runtime exports for SlackChannelAdapter and createAdapter from `./adapters/index.ts`.

    **Tests (`packages/shared/src/channels/__tests__/slack-adapter.test.ts`):**
    Mock `@slack/web-api` WebClient. Tests:
    - configure() stores client; start() calls auth.test and begins polling
    - poll() calls conversations.history with oldest timestamp
    - poll() skips messages from bot (bot_id match)
    - poll() skips messages from bot (user match)
    - toChannelMessage correctly maps Slack message fields
    - toChannelMessage sets replyTo for threaded messages
    - toChannelMessage omits replyTo for non-threaded messages
    - stop() clears interval and sets healthy to false
    - isHealthy() returns false after poll error
    - getLastError() returns error message after poll failure
    - Polling state get/set callbacks invoked when provided

    Use `mock` from bun:test to mock the WebClient module.
  </action>
  <verify>
    `bun test packages/shared/src/channels/__tests__/slack-adapter.test.ts` passes.
    `bun run typecheck:all` passes.
  </verify>
  <done>
    SlackChannelAdapter polls Slack conversations.history, filters bot messages, converts to ChannelMessage, tracks polling state, and reports health. Tests cover all behaviors with mocked WebClient.
  </done>
</task>

<task type="auto">
  <name>Task 2: ChannelRunner and daemon entry wiring</name>
  <files>
    packages/shared/src/daemon/channel-runner.ts
    packages/shared/src/daemon/__tests__/channel-runner.test.ts
    packages/shared/src/daemon/entry.ts
    packages/shared/src/daemon/index.ts
    packages/core/src/types/daemon.ts
  </files>
  <action>
    **Create `packages/shared/src/daemon/channel-runner.ts`:**

    ChannelRunner manages the lifecycle of channel adapters within the daemon process.

    Constructor takes:
    - `queue: MessageQueue` — for enqueuing inbound messages and polling state persistence
    - `emit: (event: DaemonEvent) => void` — for emitting events to Electron
    - `workspaceConfigs: Map<string, { workspaceId: string; configs: ChannelConfig[]; tokens: Map<string, string> }>` — channel configs grouped by workspace

    State:
    - `private adapters: Map<string, { adapter: ChannelAdapter; workspaceId: string; config: ChannelConfig }>` — running adapters keyed by config slug
    - `private triggerMatchers: Map<string, TriggerMatcher>` — one per adapter

    `async startAll(): Promise<void>`:
    1. For each workspace, for each enabled config:
       - Call `createAdapter(config.adapter)` to get adapter instance.
       - If null (unknown adapter type), emit plugin_error event and continue.
       - If adapter has `configure` method (duck-type check), call it with the token from tokens map and polling state callbacks `{ get: (aid, cid) => queue.getPollingState(aid, cid), set: (aid, cid, ts) => queue.setPollingState(aid, cid, ts) }`.
       - Create TriggerMatcher from `config.filter?.triggerPatterns ?? []`.
       - Call `adapter.start(config, (msg) => this.handleMessage(slug, workspaceId, msg))`.
       - Store in adapters map.
       - Emit `message_received`-style event? No: emit nothing on start. The research mentions `plugin_loaded` for plugins; adapters are loaded by plugins in Phase 13. For now, log via stderr.
    2. Log count of started adapters.

    `private handleMessage(slug: string, workspaceId: string, msg: ChannelMessage): void`:
    1. Check TriggerMatcher: if `!matcher.matches(msg.content)`, skip (log debug).
    2. Resolve session key: `ChannelSessionResolver.resolveSessionKey(slug, workspaceId, msg.replyTo?.threadId, msg.metadata.slackChannel as string ?? msg.channelId)`. Use the platform-specific channel ID from metadata for the channelSourceId, falling back to msg.channelId.
    3. Attach sessionKey to message metadata: `msg.metadata.sessionKey = sessionKey`.
    4. Enqueue: `queue.enqueue('inbound', slug, msg)`.
    5. Emit: `{ type: 'message_received', channelId: slug, messageId: msg.id }`.

    `async stopAll(): Promise<void>`:
    1. For each adapter, call `adapter.stop()`.
    2. Clear maps.

    **Add `configure_channels` DaemonCommand variant:**

    Update `packages/core/src/types/daemon.ts` to add:
    ```typescript
    | {
        type: 'configure_channels';
        /** Channel configurations grouped by workspace */
        workspaces: Array<{
          workspaceId: string;
          configs: ChannelConfig[];
          tokens: Record<string, string>;
        }>;
      }
    ```

    Import ChannelConfig type in daemon.ts. Since core should not depend on shared, duplicate a minimal ChannelConfig reference or use the existing import path. Check: `ChannelConfig` is defined in `packages/shared/src/channels/types.ts`. Core cannot import from shared. Instead, use an inline type in the command or import from a shared location.

    **Resolution:** Keep DaemonCommand payload loosely typed for configure_channels. Use `configs: unknown[]` and `tokens: Record<string, string>` in the core type. The daemon entry point (in shared package) casts to ChannelConfig at the handling boundary. This avoids a circular dependency.

    ```typescript
    | {
        type: 'configure_channels';
        workspaces: Array<{
          workspaceId: string;
          configs: unknown[];
          tokens: Record<string, string>;
        }>;
      }
    ```

    **Update `packages/shared/src/daemon/entry.ts`:**

    1. Import ChannelRunner from `./channel-runner.ts`.
    2. After MessageQueue initialization, create a `let channelRunner: ChannelRunner | null = null`.
    3. Add `configure_channels` case to the command switch:
       ```typescript
       case 'configure_channels': {
         if (channelRunner) {
           await channelRunner.stopAll();
         }
         const workspaceConfigs = new Map();
         for (const ws of cmd.workspaces) {
           workspaceConfigs.set(ws.workspaceId, {
             workspaceId: ws.workspaceId,
             configs: ws.configs as ChannelConfig[],
             tokens: new Map(Object.entries(ws.tokens)),
           });
         }
         channelRunner = new ChannelRunner(queue, emit, workspaceConfigs);
         await channelRunner.startAll();
         break;
       }
       ```
    4. In graceful shutdown section (before queue.close()), add: `if (channelRunner) await channelRunner.stopAll()`.
    5. The command handler switch contains an `await` now, so the parser callback must be async-aware. Refactor the parser callback to push commands to an array and process them in the main loop, OR make the parser callback dispatch to an async handler. Simplest approach: collect commands in an array, process in the while loop:

       ```typescript
       const pendingCommands: DaemonCommand[] = [];
       const parser = createLineParser((line: string) => {
         try {
           pendingCommands.push(JSON.parse(line) as DaemonCommand);
         } catch { log(`Failed to parse command: ${line}`); }
       });

       while (running) {
         const { value, done } = await reader.read();
         if (done) { log('stdin closed'); break; }
         parser(decoder.decode(value, { stream: true }));

         // Process pending commands
         while (pendingCommands.length > 0) {
           const cmd = pendingCommands.shift()!;
           await handleCommand(cmd);
         }
       }
       ```

       Extract command handling into `async function handleCommand(cmd: DaemonCommand)`.

    **Update `packages/shared/src/daemon/index.ts`:**
    Add export for ChannelRunner.

    **Tests (`packages/shared/src/daemon/__tests__/channel-runner.test.ts`):**
    - startAll creates adapters for each enabled config
    - startAll skips disabled configs
    - startAll skips unknown adapter types and emits error
    - handleMessage enqueues message when trigger matches
    - handleMessage skips message when trigger does not match
    - handleMessage attaches sessionKey to message metadata
    - stopAll calls stop on all running adapters

    Mock createAdapter to return fake adapters. Mock MessageQueue.
  </action>
  <verify>
    `bun test packages/shared/src/daemon/__tests__/channel-runner.test.ts` passes.
    `bun test packages/shared/src/channels/` passes (no regressions from Plan 01).
    `bun run typecheck:all` passes.
    `bun test` — full suite passes.
  </verify>
  <done>
    ChannelRunner orchestrates adapter lifecycle with trigger filtering and session resolution. Daemon entry point handles configure_channels command. Slack adapter is wired end-to-end from daemon command to MessageQueue enqueue.
  </done>
</task>

</tasks>

<verification>
- `bun test packages/shared/src/channels/` — all adapter and infrastructure tests pass
- `bun test packages/shared/src/daemon/` — all daemon tests pass including channel-runner
- `bun run typecheck:all` — zero errors
- `bun test` — full suite passes, no regressions
- SlackChannelAdapter polls with oldest timestamp, skips bot messages, persists polling state
- ChannelRunner applies trigger patterns and resolves session keys before enqueuing
</verification>

<success_criteria>
- Slack adapter polls conversations.history and enqueues ChannelMessage objects (CHAN-01)
- Channel-runner filters by trigger patterns (CHAN-05 partial)
- Channel-runner resolves session keys per thread (CHAN-04 partial)
- Daemon accepts configure_channels command and starts adapters
- Bot self-reply loop prevention via auth.test identity check
- Polling state persists across adapter restarts
</success_criteria>

<output>
After completion, create `.planning/phases/pending/12-channel-adapters/12-02-SUMMARY.md`
</output>

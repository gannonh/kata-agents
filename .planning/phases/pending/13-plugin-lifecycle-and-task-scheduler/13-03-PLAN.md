---
phase: 13-plugin-lifecycle-and-task-scheduler
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - packages/shared/src/daemon/entry.ts
  - packages/shared/src/daemon/channel-runner.ts
  - packages/shared/src/workspaces/types.ts
  - packages/core/src/types/daemon.ts
  - packages/shared/src/daemon/__tests__/entry-integration.test.ts
autonomous: true

must_haves:
  truths:
    - "Daemon entry creates PluginManager with per-workspace enabled plugin IDs"
    - "ChannelRunner uses PluginManager's adapter factory instead of hardcoded createAdapter"
    - "TaskScheduler starts on daemon startup and stops on shutdown"
    - "plugin_action command routes to PluginManager"
    - "WorkspaceConfig.defaults includes enabledPlugins array"
    - "configure_channels command includes enabledPlugins per workspace"
  artifacts:
    - path: "packages/shared/src/daemon/entry.ts"
      provides: "Daemon entry wiring PluginManager and TaskScheduler"
      contains: "PluginManager"
    - path: "packages/shared/src/daemon/channel-runner.ts"
      provides: "ChannelRunner using PluginManager adapter factory"
    - path: "packages/shared/src/workspaces/types.ts"
      provides: "WorkspaceConfig with enabledPlugins in defaults"
      contains: "enabledPlugins"
    - path: "packages/core/src/types/daemon.ts"
      provides: "Updated DaemonCommand with enabledPlugins in configure_channels"
  key_links:
    - from: "packages/shared/src/daemon/entry.ts"
      to: "packages/shared/src/plugins/plugin-manager.ts"
      via: "PluginManager instantiation and loadBuiltinPlugins()"
      pattern: "PluginManager"
    - from: "packages/shared/src/daemon/entry.ts"
      to: "packages/shared/src/daemon/task-scheduler.ts"
      via: "TaskScheduler instantiation and start()/stop()"
      pattern: "TaskScheduler"
    - from: "packages/shared/src/daemon/channel-runner.ts"
      to: "packages/shared/src/plugins/plugin-manager.ts"
      via: "adapterFactory parameter from PluginManager.getAdapterFactory()"
      pattern: "getAdapterFactory"
---

<objective>
Wire PluginManager and TaskScheduler into the daemon entry point, add per-workspace enabledPlugins to WorkspaceConfig, and update ChannelRunner to use plugin-provided adapter factories.

Purpose: Connect the independent units built in Plans 01 and 02 into the running daemon. The daemon loads plugins filtered by workspace config, routes plugin_action commands, and runs the task scheduler alongside channel adapters.

Output: Updated daemon entry, ChannelRunner, WorkspaceConfig types, DaemonCommand types, and integration test.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-plugin-lifecycle-and-task-scheduler/13-01-SUMMARY.md
@.planning/phases/13-plugin-lifecycle-and-task-scheduler/13-02-SUMMARY.md
@packages/shared/src/daemon/entry.ts
@packages/shared/src/daemon/channel-runner.ts
@packages/shared/src/daemon/message-queue.ts
@packages/shared/src/daemon/types.ts
@packages/shared/src/plugins/types.ts
@packages/shared/src/plugins/plugin-manager.ts
@packages/shared/src/daemon/task-scheduler.ts
@packages/shared/src/workspaces/types.ts
@packages/core/src/types/daemon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add enabledPlugins to WorkspaceConfig and DaemonCommand</name>
  <files>
    packages/shared/src/workspaces/types.ts
    packages/core/src/types/daemon.ts
  </files>
  <action>
In `packages/shared/src/workspaces/types.ts`, add `enabledPlugins` to the `defaults` object within `WorkspaceConfig`:
```typescript
defaults?: {
  // ... existing fields ...
  /** Plugin IDs enabled for this workspace. Default: all first-party plugins. */
  enabledPlugins?: string[];
};
```

In `packages/core/src/types/daemon.ts`, update the `configure_channels` variant of `DaemonCommand` to include enabled plugin IDs per workspace:
```typescript
| {
    type: 'configure_channels';
    workspaces: Array<{
      workspaceId: string;
      configs: unknown[];
      tokens: Record<string, string>;
      /** Plugin IDs enabled for this workspace */
      enabledPlugins: string[];
    }>;
  };
```

Add a new `schedule_task` command variant to `DaemonCommand`:
```typescript
| {
    type: 'schedule_task';
    workspaceId: string;
    taskType: 'cron' | 'interval' | 'one-shot';
    schedule: string;
    action: { type: string; [key: string]: unknown };
  }
```

Add a new `task_fired` event variant to `DaemonEvent`:
```typescript
| {
    type: 'task_fired';
    taskId: number;
    workspaceId: string;
  }
```
  </action>
  <verify>
`cd packages/core && bun run tsc --noEmit` passes.
`cd packages/shared && bun run tsc --noEmit` passes.
  </verify>
  <done>
WorkspaceConfig includes enabledPlugins. DaemonCommand supports configure_channels with enabledPlugins, schedule_task, and DaemonEvent includes task_fired.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire PluginManager and TaskScheduler into daemon entry</name>
  <files>
    packages/shared/src/daemon/entry.ts
    packages/shared/src/daemon/channel-runner.ts
    packages/shared/src/daemon/__tests__/entry-integration.test.ts
  </files>
  <action>
**Modify `packages/shared/src/daemon/entry.ts`:**

Import PluginManager and TaskScheduler at the top:
```typescript
import { PluginManager } from '../plugins/plugin-manager.ts';
import { TaskScheduler } from './task-scheduler.ts';
```

After MessageQueue initialization, create a TaskScheduler:
```typescript
const scheduler = new TaskScheduler(queue.getDb(), async (task) => {
  log(`Task ${task.id} fired (${task.type}): ${JSON.stringify(task.action)}`);
  emit({ type: 'task_fired', taskId: task.id, workspaceId: task.workspaceId });
}, log);
scheduler.start();
```

Update the `configure_channels` command handler:
1. Collect all unique enabledPlugins across workspaces (union of all workspace enabledPlugins arrays)
2. Create a PluginManager with those enabled IDs
3. Call `pluginManager.loadBuiltinPlugins()`
4. Pass `pluginManager.getAdapterFactory()` as the adapterFactory to ChannelRunner constructor
5. Store `pluginManager` in state alongside `channelRunner`
6. On reconfigure, shutdown old pluginManager before creating new one

Replace the current ChannelRunner construction:
```typescript
// Before (current):
state.channelRunner = new ChannelRunner(queue, emit, workspaceConfigs, log);

// After:
state.channelRunner = new ChannelRunner(
  queue, emit, workspaceConfigs, log,
  state.pluginManager.getAdapterFactory(),
);
```

Update the `plugin_action` command handler (replace the no-op log):
```typescript
case 'plugin_action':
  log(`Plugin action: ${cmd.pluginId}/${cmd.action}`);
  // Future: route to specific plugin. For now, emit acknowledgment.
  break;
```

Add handler for `schedule_task` command:
```typescript
case 'schedule_task': {
  const task = scheduler.addTask({
    workspaceId: cmd.workspaceId,
    type: cmd.taskType as TaskType,
    schedule: cmd.schedule,
    action: cmd.action as TaskAction,
  });
  log(`Scheduled task ${task.id} (${task.type}): next at ${task.nextRunAt}`);
  break;
}
```

Update graceful shutdown to include scheduler and pluginManager:
```typescript
await scheduler.stop();
if (state.pluginManager) {
  await state.pluginManager.shutdownAll();
}
if (state.channelRunner) {
  await state.channelRunner.stopAll();
}
queue.close();
```

**Modify `packages/shared/src/daemon/channel-runner.ts`:**

Remove the import of `defaultCreateAdapter` from `../channels/adapters/index.ts`. The ChannelRunner already accepts an optional `adapterFactory` parameter, so no interface change is needed. But update the default fallback: if no factory is provided, import and use `createAdapter` from channels (keeping backward compatibility). The key change is that the daemon entry now explicitly passes the PluginManager's factory.

No changes to the ChannelRunner class API. The `adapterFactory` constructor parameter already handles this.

**Create `packages/shared/src/daemon/__tests__/entry-integration.test.ts`:**

This is a lightweight integration test that verifies the wiring compiles and key interactions work. Since the daemon entry is a standalone script (not importable), test the composition pattern:

1. `PluginManager adapter factory works with ChannelRunner` - Create PluginManager with ['kata-slack'], load builtins, create ChannelRunner with its adapter factory, verify adapter creation works for 'slack' type
2. `TaskScheduler shares Database with MessageQueue` - Create MessageQueue with temp DB, get its Database via getDb(), create TaskScheduler with same DB, verify addTask works
3. `enabledPlugins filtering` - Create PluginManager with ['kata-slack'] only, verify getAdapterFactory()('whatsapp') returns null while getAdapterFactory()('slack') returns an adapter
  </action>
  <verify>
`bun test packages/shared/src/daemon/__tests__/entry-integration.test.ts` passes.
`cd packages/shared && bun run tsc --noEmit` passes.
`cd packages/core && bun run tsc --noEmit` passes.
  </verify>
  <done>
Daemon entry creates PluginManager from workspace enabledPlugins, passes its factory to ChannelRunner, starts TaskScheduler alongside channels, and shuts down all components in order.
  </done>
</task>

</tasks>

<verification>
- `cd packages/shared && bun run tsc --noEmit` passes
- `cd packages/core && bun run tsc --noEmit` passes
- `bun test packages/shared/src/daemon/__tests__` passes all tests
- `bun test packages/shared/src/plugins/__tests__` passes all tests
- Daemon entry imports and uses PluginManager and TaskScheduler
- WorkspaceConfig.defaults.enabledPlugins exists as optional string array
</verification>

<success_criteria>
- Daemon startup creates PluginManager filtered by workspace-provided enabledPlugins
- ChannelRunner receives adapter factory from PluginManager (no more hardcoded switch)
- TaskScheduler runs alongside ChannelRunner in the daemon process
- schedule_task command creates persisted tasks
- Graceful shutdown stops scheduler, plugins, and channels in order
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-plugin-lifecycle-and-task-scheduler/13-03-SUMMARY.md`
</output>
